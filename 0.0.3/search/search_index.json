{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"urlscan-python","text":"<p>The official Python API client for urlscan.io.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install urlscan-python\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Start by importing <code>urlscan</code> module</p> <pre><code>&gt;&gt;&gt; import urlscan\n</code></pre> <p>Create a client with your API key:</p> <pre><code>&gt;&gt;&gt; client = urlscan.Client(\"&lt;your_api_key&gt;\")\n</code></pre> <p>Scan a URL:</p> <pre><code>&gt;&gt;&gt; res = client.scan(\"&lt;url&gt;\", visibility=\"public\")\n&gt;&gt;&gt; uuid: str = res[\"uuid\"]\n</code></pre> <p>Wait for a scan result:</p> <pre><code>&gt;&gt;&gt; client.wait_for_result(uuid)\n</code></pre> <p>Get a scan result:</p> <pre><code>&gt;&gt;&gt; result = client.get_result(uuid)\n</code></pre> <p>Bulk scan:</p> <pre><code>&gt;&gt;&gt; client.bulk_scan([\"&lt;url&gt;\", \"&lt;url&gt;\"], visibility=\"public\")\n</code></pre> <p>Alternatively, you can use <code>_and_get_result(s)</code> suffixed methods to do scan, wait and get at once.</p> <pre><code>&gt;&gt;&gt; client.scan_and_get_result(\"&lt;url&gt;\", visibility=\"public\")\n&gt;&gt;&gt; client.bulk_scan_and_get_results([\"&lt;url&gt;\", \"&lt;url&gt;\"], visibility=\"public\")\n</code></pre> <p><code>urlscan.Client.search()</code> returns an iterator to iterate search results:</p> <pre><code>&gt;&gt;&gt; for result in client.search(\"page.domain:example.com\"):\n&gt;&gt;&gt;     print(result[\"_id\"])\n</code></pre>"},{"location":"#pro","title":"Pro","text":"<p>Use <code>Pro</code> class to interact with the pro API endpoints:</p> <pre><code>from urlscan import Pro\n\nwith Pro(\"&lt;your_api_key&gt;\") as client:\n    res = client.livescan.scan(\"&lt;url&gt;\", scanner_id=\"us01\")\n    resource_id: str = res[\"uuid\"]\n    result = client.livescan.get_resource(scanner_id=\"us01\", resource_id=resource_id, resource_type=\"result\")\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>See Examples.</p>"},{"location":"#references","title":"References","text":"<ul> <li>Client</li> <li>Iterator</li> <li>Pro</li> <li>Errors</li> </ul>"},{"location":"#help-wanted","title":"Help Wanted?","text":"<p>Please feel free to to open an issue if you find a bug or some feature that you want to see implemented.</p>"},{"location":"dev/","title":"Development","text":"<p>This doc explains how to set up dev env if you want to get involved with this project.</p>"},{"location":"dev/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> </ul>"},{"location":"dev/#setup","title":"Setup","text":"<p>This project uses uv as a project manager and Lefthook as a Git hooks manager.</p> <pre><code>git clone https://github.com/urlscan/urlscan-python\ncd urlscan-python\n\n# install uv\npip install -r requirements.txt\n# sync uv\nuv sync\n# install Lefthook\nuv run lefthook install\n</code></pre>"},{"location":"dev/#test","title":"Test","text":"<p>This project uses pytest as a testing framework.</p>"},{"location":"dev/#unit-test","title":"Unit Test","text":"<p>Unit tests use a mock HTTP server (csernazs/pytest-httpserver) and are located under <code>&lt;root&gt;/tests/unit/</code></p> <pre><code>uv run pytest\n</code></pre>"},{"location":"dev/#integration-test","title":"Integration Test","text":"<p>Integration tests require the environment variable <code>URLSCAN_API_KEY</code> and located under <code>&lt;root&gt;/tests/integration/</code></p> <pre><code>uv run pytest --run-optional-tests=integration\n</code></pre>"},{"location":"dev/#docs","title":"Docs","text":"<p>This project uses MkDocs as a documentation tool and uses Mike for versioning.</p> <pre><code># run the dev server\nuv run mike serve\n# or build the docs\nuv run mke build\n</code></pre>"},{"location":"references/client/","title":"Client","text":""},{"location":"references/client/#urlscan.Client","title":"<code>urlscan.Client</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Main client for urlscan.io API.</p> Source code in <code>src/urlscan/client.py</code> <pre><code>class Client(BaseClient):\n    \"\"\"Main client for urlscan.io API.\"\"\"\n\n    def get_result(self, uuid: str) -&gt; dict:\n        \"\"\"Get a result of a scan by UUID.\n\n        Args:\n            uuid (str): UUID.\n\n        Returns:\n            Dict: Scan result.\n\n        Reference:\n            https://urlscan.io/docs/api/#result\n\n        \"\"\"\n        return self.get_json(f\"/api/v1/result/{uuid}/\")\n\n    def get_screenshot(self, uuid: str) -&gt; BytesIO:\n        \"\"\"Get a screenshot of a scan by UUID.\n\n        Args:\n            uuid (str): UUID.\n\n        Returns:\n            : Screenshot (img/png) as bytes.\n\n        Reference:\n            https://urlscan.io/docs/api/#screenshot\n\n        \"\"\"\n        res = self._get(f\"/screenshots/{uuid}.png\")\n        bio = BytesIO(res.content)\n        bio.name = res.basename\n        return bio\n\n    def get_dom(self, uuid: str) -&gt; str:\n        \"\"\"Get a DOM of a scan by UUID.\n\n        Args:\n            uuid (str): UUID\n\n        Returns:\n            str: DOM as a string.\n\n        Reference:\n            https://urlscan.io/docs/api/#dom\n\n        \"\"\"\n        return self.get_text(f\"/dom/{uuid}/\")\n\n    def get_response(self, file_hash: str) -&gt; str:\n        \"\"\"Get a (Script|Document|Fetch|XHR) response in plain text format by SHA256 hash.\n\n        Args:\n            file_hash (str): SHA256 hash of the response.\n\n        Returns:\n            str: Response content as a string.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/scanning/response\n\n        \"\"\"\n        return self.get_text(f\"/responses/{file_hash}/\")\n\n    def search(\n        self,\n        q: str = \"\",\n        size: int = 100,\n        limit: int | None = None,\n        search_after: str | None = None,\n        datasource: SearchDataSource | None = None,\n        collapse: str | None = None,\n    ) -&gt; SearchIterator:\n        \"\"\"Search.\n\n        Args:\n            q (str): Query term. Defaults to \"\".\n            size (int, optional): Number of results returned in a search. Defaults to 100.\n            limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n            search_after (str | None, optional): Search after to retrieve next results. Defaults to None.\n            datasource (SearchDataSource | None, optional): Datasources to search: scans (urlscan.io), hostnames, incidents, notifications, certificates (urlscan Pro). Defaults to None.\n            collapse (str | None, optional): Field to collapse results on. Only works on current page of results. Defaults to None.\n\n        Returns:\n            SearchIterator: Search iterator.\n\n        Reference:\n            https://urlscan.io/docs/api/#search\n\n        \"\"\"\n        return SearchIterator(\n            self,\n            path=\"/api/v1/search/\",\n            q=q,\n            size=size,\n            limit=limit,\n            search_after=search_after,\n            datasource=datasource,\n            collapse=collapse,\n        )\n\n    def scan(\n        self,\n        url: str,\n        *,\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n    ) -&gt; dict:\n        \"\"\"Scan a given URL.\n\n        Args:\n            url (str): URL to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n        Returns:\n            dict: Scan response.\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n\n        \"\"\"\n        data = _compact(\n            {\n                \"url\": url,\n                \"tags\": tags,\n                \"visibility\": visibility,\n                \"customagent\": customagent,\n                \"referer\": referer,\n                \"overrideSafety\": override_safety,\n                \"country\": country,\n            }\n        )\n        res = self._post(\"/api/v1/scan/\", json=data)\n        json_res = self._response_to_json(res)\n\n        json_visibility = json_res.get(\"visibility\")\n        if json_visibility is not None and json_visibility != visibility:\n            logger.warning(f\"Visibility is enforced to {json_visibility}.\")\n\n        # memoize the scan UUID &amp; timestamp\n        uuid = json_res.get(\"uuid\")\n        if isinstance(uuid, str):\n            self._scan_uuid_timestamp_memo[uuid] = time.time()\n\n        return json_res\n\n    def bulk_scan(\n        self,\n        urls: list[str],\n        *,\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n    ) -&gt; list[tuple[str, dict | Exception]]:\n        \"\"\"Scan multiple URLs in bulk.\n\n        Args:\n            urls (list[str]): List of URLs to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n        Returns:\n            list[tuple[str, dict | Exception]]: A list of tuples of (url, scan response or error).\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n\n        \"\"\"\n\n        def inner(url: str) -&gt; dict | Exception:\n            try:\n                return self.scan(\n                    url,\n                    visibility=visibility,\n                    tags=tags,\n                    customagent=customagent,\n                    referer=referer,\n                    override_safety=override_safety,\n                    country=country,\n                )\n            except Exception as e:\n                return e\n\n        return [(url, inner(url)) for url in urls]\n\n    def wait_for_result(\n        self,\n        uuid: str,\n        timeout: float = 60.0,\n        interval: float = 1.0,\n        initial_wait: float | None = 10.0,\n    ) -&gt; None:\n        \"\"\"Wait for a scan result to be available.\n\n        Args:\n            uuid (str): UUID of a result.\n            timeout (float, optional): Timeout in seconds. Defaults to 60.0.\n            interval (float, optional): Interval in seconds. Defaults to 1.0.\n            initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n        \"\"\"\n        session = self._get_session()\n        req = session.build_request(\"HEAD\", f\"/api/v1/result/{uuid}/\")\n\n        scanned_at = self._scan_uuid_timestamp_memo.get(uuid)\n        if scanned_at and initial_wait:\n            elapsed = time.time() - scanned_at\n            if elapsed &lt; initial_wait:\n                time.sleep(initial_wait - elapsed)\n\n        start_time = time.time()\n        while True:\n            res = self._send_request(session, req)\n            if res.status_code == 200:\n                self._scan_uuid_timestamp_memo.pop(uuid, None)\n                return\n\n            if time.time() - start_time &gt; timeout:\n                raise TimeoutError(\"Timeout waiting for scan result.\")\n\n            time.sleep(interval)\n\n    def scan_and_get_result(\n        self,\n        url: str,\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n        timeout: float = 60.0,\n        interval: float = 1.0,\n        initial_wait: float | None = 10.0,\n    ) -&gt; dict:\n        \"\"\"Scan a given URL, wait for a result and get it.\n\n        Args:\n            url (str): URL to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n            timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n            interval (float, optional): Interval in seconds. Defaults to 1.0.\n            initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n        Returns:\n            dict: Scan result.\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n\n        \"\"\"\n        res = self.scan(\n            url,\n            visibility=visibility,\n            tags=tags,\n            customagent=customagent,\n            referer=referer,\n            override_safety=override_safety,\n            country=country,\n        )\n        uuid: str = res[\"uuid\"]\n        self.wait_for_result(\n            uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n        )\n        return self.get_result(uuid)\n\n    def bulk_scan_and_get_results(\n        self,\n        urls: list[str],\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n        timeout: float = 60.0,\n        interval: float = 1.0,\n        initial_wait: float | None = 10.0,\n    ) -&gt; list[tuple[str, dict | Exception]]:\n        \"\"\"Scan URLs, wait for results and get them.\n\n        Args:\n            urls (list[str]): URLs to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n            timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n            interval (float, optional): Interval in seconds. Defaults to 1.0.\n            initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n        Returns:\n            list[tuple[str, dict | Exception]]: A list of tuples of (url, result or error).\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n\n        \"\"\"\n        responses = self.bulk_scan(\n            urls,\n            visibility=visibility,\n            tags=tags,\n            customagent=customagent,\n            referer=referer,\n            override_safety=override_safety,\n            country=country,\n        )\n\n        def mapping(res_or_error: dict | Exception) -&gt; dict | Exception:\n            if isinstance(res_or_error, Exception):\n                return res_or_error\n\n            uuid: str = res_or_error[\"uuid\"]\n            self.wait_for_result(\n                uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n            )\n            return self.get_result(uuid)\n\n        return [(url, mapping(res_or_error)) for url, res_or_error in responses]\n\n    def get_available_countries(self) -&gt; dict:\n        \"\"\"Retrieve countries available for scanning using the Scan API.\n\n        Returns:\n            dict: Available countries.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/scanning/availablecountries\n\n        \"\"\"\n        return self.get_json(\"/api/v1/availableCountries\")\n\n    def get_user_agents(self) -&gt; dict:\n        \"\"\"Get grouped user agents to use with the Scan API.\n\n        Returns:\n            dict: Available user agents.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/scanning/useragents\n\n        \"\"\"\n        return self.get_json(\"/api/v1/userAgents\")\n\n    def get_quotas(self) -&gt; dict:\n        \"\"\"Get available and used API quotas.\n\n        Returns:\n            dict: API quotas.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/generic/quotas\n\n        \"\"\"\n        return self.get_json(\"/api/v1/quotas\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.bulk_scan","title":"<code>bulk_scan(urls, *, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None)</code>","text":"<p>Scan multiple URLs in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list[str]</code> <p>List of URLs to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[str, dict | Exception]]</code> <p>list[tuple[str, dict | Exception]]: A list of tuples of (url, scan response or error).</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def bulk_scan(\n    self,\n    urls: list[str],\n    *,\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n) -&gt; list[tuple[str, dict | Exception]]:\n    \"\"\"Scan multiple URLs in bulk.\n\n    Args:\n        urls (list[str]): List of URLs to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n    Returns:\n        list[tuple[str, dict | Exception]]: A list of tuples of (url, scan response or error).\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n\n    \"\"\"\n\n    def inner(url: str) -&gt; dict | Exception:\n        try:\n            return self.scan(\n                url,\n                visibility=visibility,\n                tags=tags,\n                customagent=customagent,\n                referer=referer,\n                override_safety=override_safety,\n                country=country,\n            )\n        except Exception as e:\n            return e\n\n    return [(url, inner(url)) for url in urls]\n</code></pre>"},{"location":"references/client/#urlscan.Client.bulk_scan_and_get_results","title":"<code>bulk_scan_and_get_results(urls, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None, timeout=60.0, interval=1.0, initial_wait=10.0)</code>","text":"<p>Scan URLs, wait for results and get them.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list[str]</code> <p>URLs to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Timeout for waiting a result in seconds. Defaults to 60.0.</p> <code>60.0</code> <code>interval</code> <code>float</code> <p>Interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <code>initial_wait</code> <code>float | None</code> <p>Initial wait time in seconds. Set None to disable. Defaults to 10.0.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>list[tuple[str, dict | Exception]]</code> <p>list[tuple[str, dict | Exception]]: A list of tuples of (url, result or error).</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def bulk_scan_and_get_results(\n    self,\n    urls: list[str],\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n    timeout: float = 60.0,\n    interval: float = 1.0,\n    initial_wait: float | None = 10.0,\n) -&gt; list[tuple[str, dict | Exception]]:\n    \"\"\"Scan URLs, wait for results and get them.\n\n    Args:\n        urls (list[str]): URLs to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n        timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n        interval (float, optional): Interval in seconds. Defaults to 1.0.\n        initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n    Returns:\n        list[tuple[str, dict | Exception]]: A list of tuples of (url, result or error).\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n\n    \"\"\"\n    responses = self.bulk_scan(\n        urls,\n        visibility=visibility,\n        tags=tags,\n        customagent=customagent,\n        referer=referer,\n        override_safety=override_safety,\n        country=country,\n    )\n\n    def mapping(res_or_error: dict | Exception) -&gt; dict | Exception:\n        if isinstance(res_or_error, Exception):\n            return res_or_error\n\n        uuid: str = res_or_error[\"uuid\"]\n        self.wait_for_result(\n            uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n        )\n        return self.get_result(uuid)\n\n    return [(url, mapping(res_or_error)) for url, res_or_error in responses]\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_available_countries","title":"<code>get_available_countries()</code>","text":"<p>Retrieve countries available for scanning using the Scan API.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Available countries.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/scanning/availablecountries</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_available_countries(self) -&gt; dict:\n    \"\"\"Retrieve countries available for scanning using the Scan API.\n\n    Returns:\n        dict: Available countries.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/scanning/availablecountries\n\n    \"\"\"\n    return self.get_json(\"/api/v1/availableCountries\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_dom","title":"<code>get_dom(uuid)</code>","text":"<p>Get a DOM of a scan by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOM as a string.</p> Reference <p>https://urlscan.io/docs/api/#dom</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_dom(self, uuid: str) -&gt; str:\n    \"\"\"Get a DOM of a scan by UUID.\n\n    Args:\n        uuid (str): UUID\n\n    Returns:\n        str: DOM as a string.\n\n    Reference:\n        https://urlscan.io/docs/api/#dom\n\n    \"\"\"\n    return self.get_text(f\"/dom/{uuid}/\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_quotas","title":"<code>get_quotas()</code>","text":"<p>Get available and used API quotas.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>API quotas.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/generic/quotas</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_quotas(self) -&gt; dict:\n    \"\"\"Get available and used API quotas.\n\n    Returns:\n        dict: API quotas.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/generic/quotas\n\n    \"\"\"\n    return self.get_json(\"/api/v1/quotas\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_response","title":"<code>get_response(file_hash)</code>","text":"<p>Get a (Script|Document|Fetch|XHR) response in plain text format by SHA256 hash.</p> <p>Parameters:</p> Name Type Description Default <code>file_hash</code> <code>str</code> <p>SHA256 hash of the response.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response content as a string.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/scanning/response</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_response(self, file_hash: str) -&gt; str:\n    \"\"\"Get a (Script|Document|Fetch|XHR) response in plain text format by SHA256 hash.\n\n    Args:\n        file_hash (str): SHA256 hash of the response.\n\n    Returns:\n        str: Response content as a string.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/scanning/response\n\n    \"\"\"\n    return self.get_text(f\"/responses/{file_hash}/\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_result","title":"<code>get_result(uuid)</code>","text":"<p>Get a result of a scan by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>dict</code> <p>Scan result.</p> Reference <p>https://urlscan.io/docs/api/#result</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_result(self, uuid: str) -&gt; dict:\n    \"\"\"Get a result of a scan by UUID.\n\n    Args:\n        uuid (str): UUID.\n\n    Returns:\n        Dict: Scan result.\n\n    Reference:\n        https://urlscan.io/docs/api/#result\n\n    \"\"\"\n    return self.get_json(f\"/api/v1/result/{uuid}/\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_screenshot","title":"<code>get_screenshot(uuid)</code>","text":"<p>Get a screenshot of a scan by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID.</p> required <p>Returns:</p> Type Description <code>BytesIO</code> <p>Screenshot (img/png) as bytes.</p> Reference <p>https://urlscan.io/docs/api/#screenshot</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_screenshot(self, uuid: str) -&gt; BytesIO:\n    \"\"\"Get a screenshot of a scan by UUID.\n\n    Args:\n        uuid (str): UUID.\n\n    Returns:\n        : Screenshot (img/png) as bytes.\n\n    Reference:\n        https://urlscan.io/docs/api/#screenshot\n\n    \"\"\"\n    res = self._get(f\"/screenshots/{uuid}.png\")\n    bio = BytesIO(res.content)\n    bio.name = res.basename\n    return bio\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_user_agents","title":"<code>get_user_agents()</code>","text":"<p>Get grouped user agents to use with the Scan API.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Available user agents.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/scanning/useragents</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_user_agents(self) -&gt; dict:\n    \"\"\"Get grouped user agents to use with the Scan API.\n\n    Returns:\n        dict: Available user agents.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/scanning/useragents\n\n    \"\"\"\n    return self.get_json(\"/api/v1/userAgents\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.scan","title":"<code>scan(url, *, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None)</code>","text":"<p>Scan a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Scan response.</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def scan(\n    self,\n    url: str,\n    *,\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n) -&gt; dict:\n    \"\"\"Scan a given URL.\n\n    Args:\n        url (str): URL to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n    Returns:\n        dict: Scan response.\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n\n    \"\"\"\n    data = _compact(\n        {\n            \"url\": url,\n            \"tags\": tags,\n            \"visibility\": visibility,\n            \"customagent\": customagent,\n            \"referer\": referer,\n            \"overrideSafety\": override_safety,\n            \"country\": country,\n        }\n    )\n    res = self._post(\"/api/v1/scan/\", json=data)\n    json_res = self._response_to_json(res)\n\n    json_visibility = json_res.get(\"visibility\")\n    if json_visibility is not None and json_visibility != visibility:\n        logger.warning(f\"Visibility is enforced to {json_visibility}.\")\n\n    # memoize the scan UUID &amp; timestamp\n    uuid = json_res.get(\"uuid\")\n    if isinstance(uuid, str):\n        self._scan_uuid_timestamp_memo[uuid] = time.time()\n\n    return json_res\n</code></pre>"},{"location":"references/client/#urlscan.Client.scan_and_get_result","title":"<code>scan_and_get_result(url, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None, timeout=60.0, interval=1.0, initial_wait=10.0)</code>","text":"<p>Scan a given URL, wait for a result and get it.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Timeout for waiting a result in seconds. Defaults to 60.0.</p> <code>60.0</code> <code>interval</code> <code>float</code> <p>Interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <code>initial_wait</code> <code>float | None</code> <p>Initial wait time in seconds. Set None to disable. Defaults to 10.0.</p> <code>10.0</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Scan result.</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def scan_and_get_result(\n    self,\n    url: str,\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n    timeout: float = 60.0,\n    interval: float = 1.0,\n    initial_wait: float | None = 10.0,\n) -&gt; dict:\n    \"\"\"Scan a given URL, wait for a result and get it.\n\n    Args:\n        url (str): URL to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n        timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n        interval (float, optional): Interval in seconds. Defaults to 1.0.\n        initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n    Returns:\n        dict: Scan result.\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n\n    \"\"\"\n    res = self.scan(\n        url,\n        visibility=visibility,\n        tags=tags,\n        customagent=customagent,\n        referer=referer,\n        override_safety=override_safety,\n        country=country,\n    )\n    uuid: str = res[\"uuid\"]\n    self.wait_for_result(\n        uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n    )\n    return self.get_result(uuid)\n</code></pre>"},{"location":"references/client/#urlscan.Client.search","title":"<code>search(q='', size=100, limit=None, search_after=None, datasource=None, collapse=None)</code>","text":"<p>Search.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str</code> <p>Query term. Defaults to \"\".</p> <code>''</code> <code>size</code> <code>int</code> <p>Number of results returned in a search. Defaults to 100.</p> <code>100</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> <code>search_after</code> <code>str | None</code> <p>Search after to retrieve next results. Defaults to None.</p> <code>None</code> <code>datasource</code> <code>SearchDataSource | None</code> <p>Datasources to search: scans (urlscan.io), hostnames, incidents, notifications, certificates (urlscan Pro). Defaults to None.</p> <code>None</code> <code>collapse</code> <code>str | None</code> <p>Field to collapse results on. Only works on current page of results. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SearchIterator</code> <code>SearchIterator</code> <p>Search iterator.</p> Reference <p>https://urlscan.io/docs/api/#search</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def search(\n    self,\n    q: str = \"\",\n    size: int = 100,\n    limit: int | None = None,\n    search_after: str | None = None,\n    datasource: SearchDataSource | None = None,\n    collapse: str | None = None,\n) -&gt; SearchIterator:\n    \"\"\"Search.\n\n    Args:\n        q (str): Query term. Defaults to \"\".\n        size (int, optional): Number of results returned in a search. Defaults to 100.\n        limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n        search_after (str | None, optional): Search after to retrieve next results. Defaults to None.\n        datasource (SearchDataSource | None, optional): Datasources to search: scans (urlscan.io), hostnames, incidents, notifications, certificates (urlscan Pro). Defaults to None.\n        collapse (str | None, optional): Field to collapse results on. Only works on current page of results. Defaults to None.\n\n    Returns:\n        SearchIterator: Search iterator.\n\n    Reference:\n        https://urlscan.io/docs/api/#search\n\n    \"\"\"\n    return SearchIterator(\n        self,\n        path=\"/api/v1/search/\",\n        q=q,\n        size=size,\n        limit=limit,\n        search_after=search_after,\n        datasource=datasource,\n        collapse=collapse,\n    )\n</code></pre>"},{"location":"references/client/#urlscan.Client.wait_for_result","title":"<code>wait_for_result(uuid, timeout=60.0, interval=1.0, initial_wait=10.0)</code>","text":"<p>Wait for a scan result to be available.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID of a result.</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds. Defaults to 60.0.</p> <code>60.0</code> <code>interval</code> <code>float</code> <p>Interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <code>initial_wait</code> <code>float | None</code> <p>Initial wait time in seconds. Set None to disable. Defaults to 10.0.</p> <code>10.0</code> Source code in <code>src/urlscan/client.py</code> <pre><code>def wait_for_result(\n    self,\n    uuid: str,\n    timeout: float = 60.0,\n    interval: float = 1.0,\n    initial_wait: float | None = 10.0,\n) -&gt; None:\n    \"\"\"Wait for a scan result to be available.\n\n    Args:\n        uuid (str): UUID of a result.\n        timeout (float, optional): Timeout in seconds. Defaults to 60.0.\n        interval (float, optional): Interval in seconds. Defaults to 1.0.\n        initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n    \"\"\"\n    session = self._get_session()\n    req = session.build_request(\"HEAD\", f\"/api/v1/result/{uuid}/\")\n\n    scanned_at = self._scan_uuid_timestamp_memo.get(uuid)\n    if scanned_at and initial_wait:\n        elapsed = time.time() - scanned_at\n        if elapsed &lt; initial_wait:\n            time.sleep(initial_wait - elapsed)\n\n    start_time = time.time()\n    while True:\n        res = self._send_request(session, req)\n        if res.status_code == 200:\n            self._scan_uuid_timestamp_memo.pop(uuid, None)\n            return\n\n        if time.time() - start_time &gt; timeout:\n            raise TimeoutError(\"Timeout waiting for scan result.\")\n\n        time.sleep(interval)\n</code></pre>"},{"location":"references/errors/","title":"Errors","text":""},{"location":"references/errors/#urlscan.APIError","title":"<code>urlscan.APIError</code>","text":"<p>               Bases: <code>URLScanError</code></p> <p>Exception raised for API errors.</p> Source code in <code>src/urlscan/error.py</code> <pre><code>class APIError(URLScanError):\n    \"\"\"Exception raised for API errors.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        status: int,\n        description: str | None = None,\n        errors: list[ItemError] | None = None,\n        code: str | None = None,\n        type_: str | None = None,\n    ):\n        \"\"\"Initialize the API error.\n\n        Args:\n            message (str): error message.\n            status (int): error status.\n            description (str | None, optional): error description. Defaults to None.\n            errors (list[ErrorItem] | None, optional): error items. Defaults to None.\n            code (str | None, optional): error code. Defaults to None.\n            type_ (str | None, optional): error type. Defaults to None.\n\n        \"\"\"\n        self.message = message\n        self.description = description\n        self.status = status\n        self.errors = errors\n        self.code = code\n        self.type = type_\n        super().__init__(message)\n</code></pre>"},{"location":"references/errors/#urlscan.APIError.__init__","title":"<code>__init__(message, *, status, description=None, errors=None, code=None, type_=None)</code>","text":"<p>Initialize the API error.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>error message.</p> required <code>status</code> <code>int</code> <p>error status.</p> required <code>description</code> <code>str | None</code> <p>error description. Defaults to None.</p> <code>None</code> <code>errors</code> <code>list[ErrorItem] | None</code> <p>error items. Defaults to None.</p> <code>None</code> <code>code</code> <code>str | None</code> <p>error code. Defaults to None.</p> <code>None</code> <code>type_</code> <code>str | None</code> <p>error type. Defaults to None.</p> <code>None</code> Source code in <code>src/urlscan/error.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    status: int,\n    description: str | None = None,\n    errors: list[ItemError] | None = None,\n    code: str | None = None,\n    type_: str | None = None,\n):\n    \"\"\"Initialize the API error.\n\n    Args:\n        message (str): error message.\n        status (int): error status.\n        description (str | None, optional): error description. Defaults to None.\n        errors (list[ErrorItem] | None, optional): error items. Defaults to None.\n        code (str | None, optional): error code. Defaults to None.\n        type_ (str | None, optional): error type. Defaults to None.\n\n    \"\"\"\n    self.message = message\n    self.description = description\n    self.status = status\n    self.errors = errors\n    self.code = code\n    self.type = type_\n    super().__init__(message)\n</code></pre>"},{"location":"references/errors/#urlscan.RateLimitError","title":"<code>urlscan.RateLimitError</code>","text":"<p>               Bases: <code>APIError</code></p> <p>Exception raised when rate limit is exceeded.</p> Source code in <code>src/urlscan/error.py</code> <pre><code>class RateLimitError(APIError):\n    \"\"\"Exception raised when rate limit is exceeded.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        status: int,\n        rate_limit_reset_after: float,\n        description: str | None = None,\n    ):\n        \"\"\"Initialize the rate limit error.\n\n        Args:\n            message: Error message.\n            status: HTTP status code.\n            rate_limit_reset_after: Seconds until rate limit resets.\n            description: Optional error description.\n\n        \"\"\"\n        super().__init__(message, description=description, status=status)\n        self.rate_limit_reset_after = rate_limit_reset_after\n</code></pre>"},{"location":"references/errors/#urlscan.RateLimitError.__init__","title":"<code>__init__(message, *, status, rate_limit_reset_after, description=None)</code>","text":"<p>Initialize the rate limit error.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message.</p> required <code>status</code> <code>int</code> <p>HTTP status code.</p> required <code>rate_limit_reset_after</code> <code>float</code> <p>Seconds until rate limit resets.</p> required <code>description</code> <code>str | None</code> <p>Optional error description.</p> <code>None</code> Source code in <code>src/urlscan/error.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    status: int,\n    rate_limit_reset_after: float,\n    description: str | None = None,\n):\n    \"\"\"Initialize the rate limit error.\n\n    Args:\n        message: Error message.\n        status: HTTP status code.\n        rate_limit_reset_after: Seconds until rate limit resets.\n        description: Optional error description.\n\n    \"\"\"\n    super().__init__(message, description=description, status=status)\n    self.rate_limit_reset_after = rate_limit_reset_after\n</code></pre>"},{"location":"references/iterator/","title":"Iterator","text":""},{"location":"references/iterator/#urlscan.SearchIterator","title":"<code>urlscan.SearchIterator</code>","text":"<p>               Bases: <code>BaseIterator</code></p> <p>Search iterator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from urlscan import Client\n&gt;&gt;&gt; with Client(\"&lt;your_api_key&gt;\") as client:\n...     for result in client.search(\"page.domain:example.com\"):\n...         print(result[\"_id\"], result[\"page\"][\"url\"])\n</code></pre> Source code in <code>src/urlscan/iterator.py</code> <pre><code>class SearchIterator(BaseIterator):\n    \"\"\"Search iterator.\n\n    Examples:\n        &gt;&gt;&gt; from urlscan import Client\n        &gt;&gt;&gt; with Client(\"&lt;your_api_key&gt;\") as client:\n        ...     for result in client.search(\"page.domain:example.com\"):\n        ...         print(result[\"_id\"], result[\"page\"][\"url\"])\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"BaseClient\",\n        *,\n        path: str,\n        q: str | None = None,\n        search_after: str | None = None,\n        size: int = 100,\n        limit: int | None = None,\n        datasource: SearchDataSource | None = None,\n        collapse: str | None = None,\n    ):\n        \"\"\"Initialize the search iterator.\n\n        Args:\n            client (Client): Client.\n            path (str): API path for the search endpoint.\n            q (str | None, optional): Search query. Defaults to None.\n            search_after (str | None, optional): Search after to retrieve next results. Defaults to None.\n            size (int, optional): Number of results returned in a search. Defaults to 100.\n            limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n            datasource (SearchDataSource | None, optional): Datasources to search: scans (urlscan.io), hostnames, incidents, notifications, certificates (urlscan Pro). Defaults to None.\n            collapse (str | None, optional): Field to collapse results on. Only works on current page of results. Defaults to None.\n\n        \"\"\"\n        self._client = client\n        self._path = path\n        self._size = size\n        self._q = q\n        self._search_after = search_after\n        self._datasource = datasource\n        self._collapse = collapse\n\n        self._results: list[dict] = []\n        self._limit = limit\n        self._count = 0\n        self._total: int | None = None\n        self._has_more: bool = True\n\n    def _parse_response(self, data: dict) -&gt; tuple[list[dict], int]:\n        results: list[dict] = data[\"results\"]\n        total: int = data[\"total\"]\n        return results, total\n\n    def _get(self):\n        data = self._client.get_json(\n            self._path,\n            params=_compact(\n                {\n                    \"q\": self._q,\n                    \"size\": self._size,\n                    \"search_after\": self._search_after,\n                    \"datasource\": self._datasource,\n                    \"collapse\": self._collapse,\n                }\n            ),\n        )\n        return self._parse_response(data)\n\n    def __iter__(self):\n        \"\"\"Return the iterator object.\"\"\"\n        return self\n\n    def __next__(self):\n        \"\"\"Return the next search result.\"\"\"\n        if self._limit and self._count &gt;= self._limit:\n            raise StopIteration()\n\n        if not self._results and (self._count == 0 or self._has_more):\n            self._results, total = self._get()\n\n            # NOTE: total should be set only once (to ignore newly added results after the first request)\n            self._total = self._total or total\n            if self._total != MAX_TOTAL:\n                self._has_more = self._total &gt; (self._count + len(self._results))\n            else:\n                self._has_more = len(self._results) &gt;= self._size\n\n            if len(self._results) &gt; 0:\n                last_result = self._results[-1]\n                sort: list[str | int] = last_result[\"sort\"]\n                self._search_after = \",\".join(str(x) for x in sort)\n\n        if not self._results:\n            raise StopIteration()\n\n        result = self._results.pop(0)\n        self._count += 1\n        return result\n</code></pre>"},{"location":"references/iterator/#urlscan.SearchIterator.__init__","title":"<code>__init__(client, *, path, q=None, search_after=None, size=100, limit=None, datasource=None, collapse=None)</code>","text":"<p>Initialize the search iterator.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>Client.</p> required <code>path</code> <code>str</code> <p>API path for the search endpoint.</p> required <code>q</code> <code>str | None</code> <p>Search query. Defaults to None.</p> <code>None</code> <code>search_after</code> <code>str | None</code> <p>Search after to retrieve next results. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Number of results returned in a search. Defaults to 100.</p> <code>100</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> <code>datasource</code> <code>SearchDataSource | None</code> <p>Datasources to search: scans (urlscan.io), hostnames, incidents, notifications, certificates (urlscan Pro). Defaults to None.</p> <code>None</code> <code>collapse</code> <code>str | None</code> <p>Field to collapse results on. Only works on current page of results. Defaults to None.</p> <code>None</code> Source code in <code>src/urlscan/iterator.py</code> <pre><code>def __init__(\n    self,\n    client: \"BaseClient\",\n    *,\n    path: str,\n    q: str | None = None,\n    search_after: str | None = None,\n    size: int = 100,\n    limit: int | None = None,\n    datasource: SearchDataSource | None = None,\n    collapse: str | None = None,\n):\n    \"\"\"Initialize the search iterator.\n\n    Args:\n        client (Client): Client.\n        path (str): API path for the search endpoint.\n        q (str | None, optional): Search query. Defaults to None.\n        search_after (str | None, optional): Search after to retrieve next results. Defaults to None.\n        size (int, optional): Number of results returned in a search. Defaults to 100.\n        limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n        datasource (SearchDataSource | None, optional): Datasources to search: scans (urlscan.io), hostnames, incidents, notifications, certificates (urlscan Pro). Defaults to None.\n        collapse (str | None, optional): Field to collapse results on. Only works on current page of results. Defaults to None.\n\n    \"\"\"\n    self._client = client\n    self._path = path\n    self._size = size\n    self._q = q\n    self._search_after = search_after\n    self._datasource = datasource\n    self._collapse = collapse\n\n    self._results: list[dict] = []\n    self._limit = limit\n    self._count = 0\n    self._total: int | None = None\n    self._has_more: bool = True\n</code></pre>"},{"location":"references/iterator/#urlscan.SearchIterator.__iter__","title":"<code>__iter__()</code>","text":"<p>Return the iterator object.</p> Source code in <code>src/urlscan/iterator.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return the iterator object.\"\"\"\n    return self\n</code></pre>"},{"location":"references/iterator/#urlscan.SearchIterator.__next__","title":"<code>__next__()</code>","text":"<p>Return the next search result.</p> Source code in <code>src/urlscan/iterator.py</code> <pre><code>def __next__(self):\n    \"\"\"Return the next search result.\"\"\"\n    if self._limit and self._count &gt;= self._limit:\n        raise StopIteration()\n\n    if not self._results and (self._count == 0 or self._has_more):\n        self._results, total = self._get()\n\n        # NOTE: total should be set only once (to ignore newly added results after the first request)\n        self._total = self._total or total\n        if self._total != MAX_TOTAL:\n            self._has_more = self._total &gt; (self._count + len(self._results))\n        else:\n            self._has_more = len(self._results) &gt;= self._size\n\n        if len(self._results) &gt; 0:\n            last_result = self._results[-1]\n            sort: list[str | int] = last_result[\"sort\"]\n            self._search_after = \",\".join(str(x) for x in sort)\n\n    if not self._results:\n        raise StopIteration()\n\n    result = self._results.pop(0)\n    self._count += 1\n    return result\n</code></pre>"},{"location":"references/pro/","title":"Pro","text":"<p>Note: you can use <code>extract</code> function in the utils module to extract a downloaded data dump file.</p> <pre><code>import os\n\nfrom urlscan import Pro\nfrom urlscan.utils import extract\n\nwith Pro(\"&lt;your_api_key&gt;\") as pro:\n    # get a list of hourly API data dump files\n    res = pro.datadump.get_list(\"hours/api/20260101/\")\n\n    # download &amp; extract them one by one\n    for f in res[\"files\"]\n        path: str = f[\"path\"]\n\n        basename = os.path.basename(path)\n        with open(basename, \"wb\") as file:\n            pro.datadump.download_file(path, file=file)\n\n        extract(basename, \"/tmp\")\n</code></pre>"},{"location":"references/pro/#urlscan.Pro","title":"<code>urlscan.Pro</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>urlscan.io Pro API client.</p> Source code in <code>src/urlscan/pro/__init__.py</code> <pre><code>class Pro(BaseClient):\n    \"\"\"urlscan.io Pro API client.\"\"\"\n\n    @cached_property\n    def brand(self) -&gt; Brand:\n        \"\"\"Brand API client instance.\n\n        Returns:\n            Brand: Brand API client instance.\n\n        \"\"\"\n        return Brand(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    @cached_property\n    def channel(self) -&gt; Channel:\n        \"\"\"Channel API client instance.\n\n        Returns:\n            Channel: Channel API client instance.\n\n        \"\"\"\n        return Channel(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    @cached_property\n    def datadump(self) -&gt; DataDump:\n        \"\"\"Data dump API client instance.\n\n        Returns:\n            DataDump: Data dump API client instance.\n\n        \"\"\"\n        return DataDump(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    @cached_property\n    def incident(self) -&gt; Incident:\n        \"\"\"Incident API client instance.\n\n        Returns:\n            Incident: Incident API client instance.\n\n        \"\"\"\n        return Incident(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    @cached_property\n    def livescan(self) -&gt; LiveScan:\n        \"\"\"Live scan API client instance.\n\n        Returns:\n            LiveScan: Live scan API client instance.\n\n        \"\"\"\n        return LiveScan(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    @cached_property\n    def saved_search(self) -&gt; SavedSearch:\n        \"\"\"Saved Search API client instance.\n\n        Returns:\n            SavedSearch: Saved Search API client instance.\n\n        \"\"\"\n        return SavedSearch(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    @cached_property\n    def subscription(self) -&gt; Subscription:\n        \"\"\"Subscription API client instance.\n\n        Returns:\n            Subscription: Subscription API client instance.\n\n        \"\"\"\n        return Subscription(\n            api_key=self._api_key,\n            base_url=self._base_url,\n            user_agent=self._user_agent,\n            trust_env=self._trust_env,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            retry=self._retry,\n        )\n\n    def structure_search(\n        self,\n        scan_id: str,\n        *,\n        q: str | None = None,\n        size: int = 100,\n        search_after: str | None = None,\n        limit: int | None = None,\n    ) -&gt; SearchIterator:\n        \"\"\"Get results structurally similar to a specific scan.\n\n        Args:\n            scan_id (str): The original scan to compare to.\n            q (str | None, optional): Additional query filter.\n            size (int): Maximum results per call. Defaults to 100.\n            search_after (str | None, optional): Parameter to iterate over older results. Defaults to None.\n            limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n        \"\"\"\n        return SearchIterator(\n            client=self,\n            path=f\"/api/v1/pro/result/{scan_id}/similar/\",\n            q=q,\n            size=size,\n            search_after=search_after,\n            limit=limit,\n        )\n\n    def hostname(\n        self,\n        hostname: str,\n        *,\n        size: int = 1000,\n        limit: int | None = None,\n        page_state: str | None = None,\n    ) -&gt; HostnameIterator:\n        \"\"\"Get the historical observations for a specific hostname.\n\n        Args:\n            hostname (str): The hostname to query.\n            page_state (str | None, optional): Page state for pagination. Defaults to None.\n            size (int, optional): Number of results returned in a search. Defaults to 1000.\n            limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n        Returns:\n            HostnameIterator: Hostname iterator.\n\n        \"\"\"\n        return HostnameIterator(\n            client=self,\n            hostname=hostname,\n            size=size,\n            limit=limit,\n            page_state=page_state,\n        )\n\n    def download_file(\n        self,\n        file_hash: str,\n        *,\n        file: BinaryIO,\n        password: str | None = None,\n        filename: str | None = None,\n    ):\n        \"\"\"Download a file by its hash.\n\n        Examples:\n            &gt;&gt;&gt; from urlscan import Pro\n            &gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as pro, open(\"downloaded_file.zip\", \"wb\") as f:\n            ...     pro.download_file(\n            ...         file_hash=\"&lt;file_hash&gt;\",\n            ...         file=f,\n            ...     )\n\n        Args:\n            file_hash (str): The hash of the file to download.\n            file (BinaryIO): File object to write to.\n            password (str | None, optional): The password to use to encrypt the ZIP file. The default password is \"urlscan!\" if it's not provided. Defaults to None.\n            filename (str | None, optional): Specify the name of the ZIP file that should be downloaded. This does not change the name of files within the ZIP archive. The default filename is {file_hash}.zip if it's not provided. Defaults to None.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/files/downloadfile\n\n        \"\"\"\n        params: dict[str, str] = _compact(\n            {\n                \"password\": password,\n                \"filename\": filename,\n            }\n        )\n        return self.download(f\"/downloads/{file_hash}\", params=params, file=file)\n\n    def get_user(self) -&gt; dict:\n        \"\"\"Get information about the current user or API key making the request.\n\n        Returns:\n            dict: User information.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/generic/prousername\n\n        \"\"\"\n        return self.get_json(\"/api/v1/pro/username\")\n</code></pre>"},{"location":"references/pro/#urlscan.Pro.brand","title":"<code>brand</code>  <code>cached</code> <code>property</code>","text":"<p>Brand API client instance.</p> <p>Returns:</p> Name Type Description <code>Brand</code> <code>Brand</code> <p>Brand API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.channel","title":"<code>channel</code>  <code>cached</code> <code>property</code>","text":"<p>Channel API client instance.</p> <p>Returns:</p> Name Type Description <code>Channel</code> <code>Channel</code> <p>Channel API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.datadump","title":"<code>datadump</code>  <code>cached</code> <code>property</code>","text":"<p>Data dump API client instance.</p> <p>Returns:</p> Name Type Description <code>DataDump</code> <code>DataDump</code> <p>Data dump API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.incident","title":"<code>incident</code>  <code>cached</code> <code>property</code>","text":"<p>Incident API client instance.</p> <p>Returns:</p> Name Type Description <code>Incident</code> <code>Incident</code> <p>Incident API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.livescan","title":"<code>livescan</code>  <code>cached</code> <code>property</code>","text":"<p>Live scan API client instance.</p> <p>Returns:</p> Name Type Description <code>LiveScan</code> <code>LiveScan</code> <p>Live scan API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.saved_search","title":"<code>saved_search</code>  <code>cached</code> <code>property</code>","text":"<p>Saved Search API client instance.</p> <p>Returns:</p> Name Type Description <code>SavedSearch</code> <code>SavedSearch</code> <p>Saved Search API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.subscription","title":"<code>subscription</code>  <code>cached</code> <code>property</code>","text":"<p>Subscription API client instance.</p> <p>Returns:</p> Name Type Description <code>Subscription</code> <code>Subscription</code> <p>Subscription API client instance.</p>"},{"location":"references/pro/#urlscan.Pro.download_file","title":"<code>download_file(file_hash, *, file, password=None, filename=None)</code>","text":"<p>Download a file by its hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from urlscan import Pro\n&gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as pro, open(\"downloaded_file.zip\", \"wb\") as f:\n...     pro.download_file(\n...         file_hash=\"&lt;file_hash&gt;\",\n...         file=f,\n...     )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_hash</code> <code>str</code> <p>The hash of the file to download.</p> required <code>file</code> <code>BinaryIO</code> <p>File object to write to.</p> required <code>password</code> <code>str | None</code> <p>The password to use to encrypt the ZIP file. The default password is \"urlscan!\" if it's not provided. Defaults to None.</p> <code>None</code> <code>filename</code> <code>str | None</code> <p>Specify the name of the ZIP file that should be downloaded. This does not change the name of files within the ZIP archive. The default filename is {file_hash}.zip if it's not provided. Defaults to None.</p> <code>None</code> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/files/downloadfile</p> Source code in <code>src/urlscan/pro/__init__.py</code> <pre><code>def download_file(\n    self,\n    file_hash: str,\n    *,\n    file: BinaryIO,\n    password: str | None = None,\n    filename: str | None = None,\n):\n    \"\"\"Download a file by its hash.\n\n    Examples:\n        &gt;&gt;&gt; from urlscan import Pro\n        &gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as pro, open(\"downloaded_file.zip\", \"wb\") as f:\n        ...     pro.download_file(\n        ...         file_hash=\"&lt;file_hash&gt;\",\n        ...         file=f,\n        ...     )\n\n    Args:\n        file_hash (str): The hash of the file to download.\n        file (BinaryIO): File object to write to.\n        password (str | None, optional): The password to use to encrypt the ZIP file. The default password is \"urlscan!\" if it's not provided. Defaults to None.\n        filename (str | None, optional): Specify the name of the ZIP file that should be downloaded. This does not change the name of files within the ZIP archive. The default filename is {file_hash}.zip if it's not provided. Defaults to None.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/files/downloadfile\n\n    \"\"\"\n    params: dict[str, str] = _compact(\n        {\n            \"password\": password,\n            \"filename\": filename,\n        }\n    )\n    return self.download(f\"/downloads/{file_hash}\", params=params, file=file)\n</code></pre>"},{"location":"references/pro/#urlscan.Pro.get_user","title":"<code>get_user()</code>","text":"<p>Get information about the current user or API key making the request.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>User information.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/generic/prousername</p> Source code in <code>src/urlscan/pro/__init__.py</code> <pre><code>def get_user(self) -&gt; dict:\n    \"\"\"Get information about the current user or API key making the request.\n\n    Returns:\n        dict: User information.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/generic/prousername\n\n    \"\"\"\n    return self.get_json(\"/api/v1/pro/username\")\n</code></pre>"},{"location":"references/pro/#urlscan.Pro.hostname","title":"<code>hostname(hostname, *, size=1000, limit=None, page_state=None)</code>","text":"<p>Get the historical observations for a specific hostname.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>The hostname to query.</p> required <code>page_state</code> <code>str | None</code> <p>Page state for pagination. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Number of results returned in a search. Defaults to 1000.</p> <code>1000</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>HostnameIterator</code> <code>HostnameIterator</code> <p>Hostname iterator.</p> Source code in <code>src/urlscan/pro/__init__.py</code> <pre><code>def hostname(\n    self,\n    hostname: str,\n    *,\n    size: int = 1000,\n    limit: int | None = None,\n    page_state: str | None = None,\n) -&gt; HostnameIterator:\n    \"\"\"Get the historical observations for a specific hostname.\n\n    Args:\n        hostname (str): The hostname to query.\n        page_state (str | None, optional): Page state for pagination. Defaults to None.\n        size (int, optional): Number of results returned in a search. Defaults to 1000.\n        limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n    Returns:\n        HostnameIterator: Hostname iterator.\n\n    \"\"\"\n    return HostnameIterator(\n        client=self,\n        hostname=hostname,\n        size=size,\n        limit=limit,\n        page_state=page_state,\n    )\n</code></pre>"},{"location":"references/pro/#urlscan.Pro.structure_search","title":"<code>structure_search(scan_id, *, q=None, size=100, search_after=None, limit=None)</code>","text":"<p>Get results structurally similar to a specific scan.</p> <p>Parameters:</p> Name Type Description Default <code>scan_id</code> <code>str</code> <p>The original scan to compare to.</p> required <code>q</code> <code>str | None</code> <p>Additional query filter.</p> <code>None</code> <code>size</code> <code>int</code> <p>Maximum results per call. Defaults to 100.</p> <code>100</code> <code>search_after</code> <code>str | None</code> <p>Parameter to iterate over older results. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> Source code in <code>src/urlscan/pro/__init__.py</code> <pre><code>def structure_search(\n    self,\n    scan_id: str,\n    *,\n    q: str | None = None,\n    size: int = 100,\n    search_after: str | None = None,\n    limit: int | None = None,\n) -&gt; SearchIterator:\n    \"\"\"Get results structurally similar to a specific scan.\n\n    Args:\n        scan_id (str): The original scan to compare to.\n        q (str | None, optional): Additional query filter.\n        size (int): Maximum results per call. Defaults to 100.\n        search_after (str | None, optional): Parameter to iterate over older results. Defaults to None.\n        limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n    \"\"\"\n    return SearchIterator(\n        client=self,\n        path=f\"/api/v1/pro/result/{scan_id}/similar/\",\n        q=q,\n        size=size,\n        search_after=search_after,\n        limit=limit,\n    )\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Brand","title":"<code>urlscan.pro.Brand</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Brand API client.</p> Source code in <code>src/urlscan/pro/brand.py</code> <pre><code>class Brand(BaseClient):\n    \"\"\"Brand API client.\"\"\"\n\n    def get_available_brands(self) -&gt; dict:\n        \"\"\"Get a list of brands that are tracked as part of urlscan's brand detection.\n\n        Returns:\n            dict: Response containing a list of brand objects.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/brands/availablebrands\n\n        \"\"\"\n        return self.get_json(\"/api/v1/pro/availableBrands\")\n\n    def get_brands(self) -&gt; dict:\n        \"\"\"Get a list of brands that we are able to detect phishing pages with the total number of detected pages and the latest hit for each brand.\n\n        This is slower than the get_available method.\n\n        Returns:\n            dict: Response containing a list of brand object with detection statistics.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/brands/brandsummary\n\n        \"\"\"\n        return self.get_json(\"/api/v1/pro/brands\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Brand.get_available_brands","title":"<code>get_available_brands()</code>","text":"<p>Get a list of brands that are tracked as part of urlscan's brand detection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing a list of brand objects.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/brands/availablebrands</p> Source code in <code>src/urlscan/pro/brand.py</code> <pre><code>def get_available_brands(self) -&gt; dict:\n    \"\"\"Get a list of brands that are tracked as part of urlscan's brand detection.\n\n    Returns:\n        dict: Response containing a list of brand objects.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/brands/availablebrands\n\n    \"\"\"\n    return self.get_json(\"/api/v1/pro/availableBrands\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Brand.get_brands","title":"<code>get_brands()</code>","text":"<p>Get a list of brands that we are able to detect phishing pages with the total number of detected pages and the latest hit for each brand.</p> <p>This is slower than the get_available method.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing a list of brand object with detection statistics.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/brands/brandsummary</p> Source code in <code>src/urlscan/pro/brand.py</code> <pre><code>def get_brands(self) -&gt; dict:\n    \"\"\"Get a list of brands that we are able to detect phishing pages with the total number of detected pages and the latest hit for each brand.\n\n    This is slower than the get_available method.\n\n    Returns:\n        dict: Response containing a list of brand object with detection statistics.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/brands/brandsummary\n\n    \"\"\"\n    return self.get_json(\"/api/v1/pro/brands\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Channel","title":"<code>urlscan.pro.Channel</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Client API client.</p> Source code in <code>src/urlscan/pro/channel.py</code> <pre><code>class Channel(BaseClient):\n    \"\"\"Client API client.\"\"\"\n\n    def get_channels(self) -&gt; dict:\n        \"\"\"Get a list of notification channels for the current user.\n\n        Returns:\n            dict: Object containing an array of channels.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/channels/channels\n\n        \"\"\"\n        return self.get_json(\"/api/v1/user/channels/\")\n\n    def create(\n        self,\n        *,\n        channel_type: ChannelTypeType,\n        name: str,\n        webhook_url: str | None = None,\n        frequency: FrequencyType | None = None,\n        email_addresses: list[str] | None = None,\n        utc_time: str | None = None,\n        is_active: bool | None = None,\n        is_default: bool | None = None,\n        ignore_time: bool | None = None,\n        week_days: list[WeekDaysType] | None = None,\n        permissions: list[ChannelPermissionType] | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Create a new channel.\n\n        Args:\n            channel_type (ChannelTypeType): Type of channel (\"webhook\" or \"email\").\n            name (str): Name of the channel.\n            webhook_url (str | None, optional): Webhook URL receiving notifications (required when channel_type is \"webhook\"). Defaults to None.\n            frequency (FrequencyType | None, optional): Frequency of notifications (\"live\", \"hourly\", or \"daily\"). Defaults to None.\n            email_addresses (list[str] | None, optional): Email addresses receiving the notifications (required when channel_type is \"email\"). Defaults to None.\n            utc_time (str | None, optional): 24 hour UTC time that daily emails are sent (e.g. 09:00). Defaults to None.\n            is_active (bool | None, optional): Whether the channel is active. Defaults to None.\n            is_default (bool | None, optional): Whether the channel is the default. Defaults to None.\n            ignore_time (bool | None, optional): Whether to ignore time constraints. Defaults to None.\n            week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n            permissions (list[ChannelPermissionType] | None, optional): Permissions associated with this channel (team:read, team:write). Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Object containing the created channel.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/channels/channelscreate\n\n        \"\"\"\n        channel: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"type\": channel_type,\n                    \"name\": name,\n                    \"webhookURL\": webhook_url,\n                    \"frequency\": frequency,\n                    \"emailAddresses\": email_addresses,\n                    \"utcTime\": utc_time,\n                    \"isActive\": is_active,\n                    \"isDefault\": is_default,\n                    \"ignoreTime\": ignore_time,\n                    \"weekDays\": week_days,\n                    \"permissions\": permissions,\n                },\n                kwargs,\n            )\n        )\n        data = {\"channel\": channel}\n\n        res = self._post(\"/api/v1/user/channels/\", json=data)\n        return self._response_to_json(res)\n\n    def get(self, channel_id: str) -&gt; dict:\n        \"\"\"Get the search results for a specific notification channel.\n\n        Args:\n            channel_id (str): Channel ID.\n\n        Returns:\n            dict: Object containing the channel.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/channels/channelsget\n\n        \"\"\"\n        return self.get_json(f\"/api/v1/user/channels/{channel_id}/\")\n\n    def update(\n        self,\n        channel_id: str,\n        *,\n        channel_type: ChannelTypeType,\n        name: str,\n        webhook_url: str | None = None,\n        frequency: FrequencyType | None = None,\n        email_addresses: list[str] | None = None,\n        utc_time: str | None = None,\n        is_active: bool | None = None,\n        is_default: bool | None = None,\n        ignore_time: bool | None = None,\n        week_days: list[WeekDaysType] | None = None,\n        permissions: list[ChannelPermissionType] | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Update an existing channel.\n\n        Args:\n            channel_id (str): Channel ID.\n            channel_type (ChannelTypeType): Type of channel (\"webhook\" or \"email\").\n            name (str): Name of the channel.\n            webhook_url (str | None, optional): Webhook URL receiving notifications (required when channel_type is \"webhook\"). Defaults to None.\n            frequency (FrequencyType | None, optional): Frequency of notifications (\"live\", \"hourly\", or \"daily\"). Defaults to None.\n            email_addresses (list[str] | None, optional): Email addresses receiving the notifications (required when channel_type is \"email\"). Defaults to None.\n            utc_time (str | None, optional): 24 hour UTC time that daily emails are sent (e.g. 09:00). Defaults to None.\n            is_active (bool | None, optional): Whether the channel is active. Defaults to None.\n            is_default (bool | None, optional): Whether the channel is the default. Defaults to None.\n            ignore_time (bool | None, optional): Whether to ignore time constraints. Defaults to None.\n            week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n            permissions (list[ChannelPermissionType] | None, optional): Permissions associated with this channel (team:read, team:write). Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Object containing the updated channel.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/channels/channelsupdate\n\n        \"\"\"\n        channel: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"type\": channel_type,\n                    \"name\": name,\n                    \"webhookURL\": webhook_url,\n                    \"frequency\": frequency,\n                    \"emailAddresses\": email_addresses,\n                    \"utcTime\": utc_time,\n                    \"isActive\": is_active,\n                    \"isDefault\": is_default,\n                    \"ignoreTime\": ignore_time,\n                    \"weekDays\": week_days,\n                    \"permissions\": permissions,\n                },\n                kwargs,\n            )\n        )\n        data = {\"channel\": channel}\n\n        res = self._put(f\"/api/v1/user/channels/{channel_id}/\", json=data)\n        return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Channel.create","title":"<code>create(*, channel_type, name, webhook_url=None, frequency=None, email_addresses=None, utc_time=None, is_active=None, is_default=None, ignore_time=None, week_days=None, permissions=None, **kwargs)</code>","text":"<p>Create a new channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_type</code> <code>ChannelTypeType</code> <p>Type of channel (\"webhook\" or \"email\").</p> required <code>name</code> <code>str</code> <p>Name of the channel.</p> required <code>webhook_url</code> <code>str | None</code> <p>Webhook URL receiving notifications (required when channel_type is \"webhook\"). Defaults to None.</p> <code>None</code> <code>frequency</code> <code>FrequencyType | None</code> <p>Frequency of notifications (\"live\", \"hourly\", or \"daily\"). Defaults to None.</p> <code>None</code> <code>email_addresses</code> <code>list[str] | None</code> <p>Email addresses receiving the notifications (required when channel_type is \"email\"). Defaults to None.</p> <code>None</code> <code>utc_time</code> <code>str | None</code> <p>24 hour UTC time that daily emails are sent (e.g. 09:00). Defaults to None.</p> <code>None</code> <code>is_active</code> <code>bool | None</code> <p>Whether the channel is active. Defaults to None.</p> <code>None</code> <code>is_default</code> <code>bool | None</code> <p>Whether the channel is the default. Defaults to None.</p> <code>None</code> <code>ignore_time</code> <code>bool | None</code> <p>Whether to ignore time constraints. Defaults to None.</p> <code>None</code> <code>week_days</code> <code>list[WeekDaysType] | None</code> <p>Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.</p> <code>None</code> <code>permissions</code> <code>list[ChannelPermissionType] | None</code> <p>Permissions associated with this channel (team:read, team:write). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Object containing the created channel.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/channels/channelscreate</p> Source code in <code>src/urlscan/pro/channel.py</code> <pre><code>def create(\n    self,\n    *,\n    channel_type: ChannelTypeType,\n    name: str,\n    webhook_url: str | None = None,\n    frequency: FrequencyType | None = None,\n    email_addresses: list[str] | None = None,\n    utc_time: str | None = None,\n    is_active: bool | None = None,\n    is_default: bool | None = None,\n    ignore_time: bool | None = None,\n    week_days: list[WeekDaysType] | None = None,\n    permissions: list[ChannelPermissionType] | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Create a new channel.\n\n    Args:\n        channel_type (ChannelTypeType): Type of channel (\"webhook\" or \"email\").\n        name (str): Name of the channel.\n        webhook_url (str | None, optional): Webhook URL receiving notifications (required when channel_type is \"webhook\"). Defaults to None.\n        frequency (FrequencyType | None, optional): Frequency of notifications (\"live\", \"hourly\", or \"daily\"). Defaults to None.\n        email_addresses (list[str] | None, optional): Email addresses receiving the notifications (required when channel_type is \"email\"). Defaults to None.\n        utc_time (str | None, optional): 24 hour UTC time that daily emails are sent (e.g. 09:00). Defaults to None.\n        is_active (bool | None, optional): Whether the channel is active. Defaults to None.\n        is_default (bool | None, optional): Whether the channel is the default. Defaults to None.\n        ignore_time (bool | None, optional): Whether to ignore time constraints. Defaults to None.\n        week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n        permissions (list[ChannelPermissionType] | None, optional): Permissions associated with this channel (team:read, team:write). Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Object containing the created channel.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/channels/channelscreate\n\n    \"\"\"\n    channel: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"type\": channel_type,\n                \"name\": name,\n                \"webhookURL\": webhook_url,\n                \"frequency\": frequency,\n                \"emailAddresses\": email_addresses,\n                \"utcTime\": utc_time,\n                \"isActive\": is_active,\n                \"isDefault\": is_default,\n                \"ignoreTime\": ignore_time,\n                \"weekDays\": week_days,\n                \"permissions\": permissions,\n            },\n            kwargs,\n        )\n    )\n    data = {\"channel\": channel}\n\n    res = self._post(\"/api/v1/user/channels/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Channel.get","title":"<code>get(channel_id)</code>","text":"<p>Get the search results for a specific notification channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>Channel ID.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Object containing the channel.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/channels/channelsget</p> Source code in <code>src/urlscan/pro/channel.py</code> <pre><code>def get(self, channel_id: str) -&gt; dict:\n    \"\"\"Get the search results for a specific notification channel.\n\n    Args:\n        channel_id (str): Channel ID.\n\n    Returns:\n        dict: Object containing the channel.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/channels/channelsget\n\n    \"\"\"\n    return self.get_json(f\"/api/v1/user/channels/{channel_id}/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Channel.get_channels","title":"<code>get_channels()</code>","text":"<p>Get a list of notification channels for the current user.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Object containing an array of channels.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/channels/channels</p> Source code in <code>src/urlscan/pro/channel.py</code> <pre><code>def get_channels(self) -&gt; dict:\n    \"\"\"Get a list of notification channels for the current user.\n\n    Returns:\n        dict: Object containing an array of channels.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/channels/channels\n\n    \"\"\"\n    return self.get_json(\"/api/v1/user/channels/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Channel.update","title":"<code>update(channel_id, *, channel_type, name, webhook_url=None, frequency=None, email_addresses=None, utc_time=None, is_active=None, is_default=None, ignore_time=None, week_days=None, permissions=None, **kwargs)</code>","text":"<p>Update an existing channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>Channel ID.</p> required <code>channel_type</code> <code>ChannelTypeType</code> <p>Type of channel (\"webhook\" or \"email\").</p> required <code>name</code> <code>str</code> <p>Name of the channel.</p> required <code>webhook_url</code> <code>str | None</code> <p>Webhook URL receiving notifications (required when channel_type is \"webhook\"). Defaults to None.</p> <code>None</code> <code>frequency</code> <code>FrequencyType | None</code> <p>Frequency of notifications (\"live\", \"hourly\", or \"daily\"). Defaults to None.</p> <code>None</code> <code>email_addresses</code> <code>list[str] | None</code> <p>Email addresses receiving the notifications (required when channel_type is \"email\"). Defaults to None.</p> <code>None</code> <code>utc_time</code> <code>str | None</code> <p>24 hour UTC time that daily emails are sent (e.g. 09:00). Defaults to None.</p> <code>None</code> <code>is_active</code> <code>bool | None</code> <p>Whether the channel is active. Defaults to None.</p> <code>None</code> <code>is_default</code> <code>bool | None</code> <p>Whether the channel is the default. Defaults to None.</p> <code>None</code> <code>ignore_time</code> <code>bool | None</code> <p>Whether to ignore time constraints. Defaults to None.</p> <code>None</code> <code>week_days</code> <code>list[WeekDaysType] | None</code> <p>Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.</p> <code>None</code> <code>permissions</code> <code>list[ChannelPermissionType] | None</code> <p>Permissions associated with this channel (team:read, team:write). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Object containing the updated channel.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/channels/channelsupdate</p> Source code in <code>src/urlscan/pro/channel.py</code> <pre><code>def update(\n    self,\n    channel_id: str,\n    *,\n    channel_type: ChannelTypeType,\n    name: str,\n    webhook_url: str | None = None,\n    frequency: FrequencyType | None = None,\n    email_addresses: list[str] | None = None,\n    utc_time: str | None = None,\n    is_active: bool | None = None,\n    is_default: bool | None = None,\n    ignore_time: bool | None = None,\n    week_days: list[WeekDaysType] | None = None,\n    permissions: list[ChannelPermissionType] | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Update an existing channel.\n\n    Args:\n        channel_id (str): Channel ID.\n        channel_type (ChannelTypeType): Type of channel (\"webhook\" or \"email\").\n        name (str): Name of the channel.\n        webhook_url (str | None, optional): Webhook URL receiving notifications (required when channel_type is \"webhook\"). Defaults to None.\n        frequency (FrequencyType | None, optional): Frequency of notifications (\"live\", \"hourly\", or \"daily\"). Defaults to None.\n        email_addresses (list[str] | None, optional): Email addresses receiving the notifications (required when channel_type is \"email\"). Defaults to None.\n        utc_time (str | None, optional): 24 hour UTC time that daily emails are sent (e.g. 09:00). Defaults to None.\n        is_active (bool | None, optional): Whether the channel is active. Defaults to None.\n        is_default (bool | None, optional): Whether the channel is the default. Defaults to None.\n        ignore_time (bool | None, optional): Whether to ignore time constraints. Defaults to None.\n        week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n        permissions (list[ChannelPermissionType] | None, optional): Permissions associated with this channel (team:read, team:write). Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Object containing the updated channel.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/channels/channelsupdate\n\n    \"\"\"\n    channel: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"type\": channel_type,\n                \"name\": name,\n                \"webhookURL\": webhook_url,\n                \"frequency\": frequency,\n                \"emailAddresses\": email_addresses,\n                \"utcTime\": utc_time,\n                \"isActive\": is_active,\n                \"isDefault\": is_default,\n                \"ignoreTime\": ignore_time,\n                \"weekDays\": week_days,\n                \"permissions\": permissions,\n            },\n            kwargs,\n        )\n    )\n    data = {\"channel\": channel}\n\n    res = self._put(f\"/api/v1/user/channels/{channel_id}/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.DataDump","title":"<code>urlscan.pro.DataDump</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Data dump API client.</p> Source code in <code>src/urlscan/pro/datadump.py</code> <pre><code>class DataDump(BaseClient):\n    \"\"\"Data dump API client.\"\"\"\n\n    def get_list(self, path: str) -&gt; dict:\n        \"\"\"List available data dump files for a specific time window, file type, and date.\n\n        Args:\n            path (str): The data dump path. Format is /{time_window}/{file_type}/{date}/.\n                        - time_window: days, hours, minutes.\n                        - file_type: api, search, screenshots, dom.\n                        - date: date of the data dump in YYYYMMDD format.\n\n        Returns:\n            dict: The list of data dump files.\n\n        Examples:\n            &gt;&gt;&gt; from urlscan import Pro\n            &gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as client:\n            ...     result = client.datadump.get_list(\"days/api/20260101\")\n\n        \"\"\"\n        return self.get_json(urljoin(\"/api/v1/datadump/list/\", path))\n\n    def download_file(\n        self,\n        path: str,\n        file: BinaryIO,\n    ):\n        \"\"\"Download the datadump file.\n\n        Args:\n            path (str): Path to API endpoint.\n            file (BinaryIO): File object to write to.\n\n        \"\"\"\n        return super().download(\n            urljoin(\"/api/v1/datadump/link/\", path),\n            file=file,\n        )\n</code></pre>"},{"location":"references/pro/#urlscan.pro.DataDump.download_file","title":"<code>download_file(path, file)</code>","text":"<p>Download the datadump file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to API endpoint.</p> required <code>file</code> <code>BinaryIO</code> <p>File object to write to.</p> required Source code in <code>src/urlscan/pro/datadump.py</code> <pre><code>def download_file(\n    self,\n    path: str,\n    file: BinaryIO,\n):\n    \"\"\"Download the datadump file.\n\n    Args:\n        path (str): Path to API endpoint.\n        file (BinaryIO): File object to write to.\n\n    \"\"\"\n    return super().download(\n        urljoin(\"/api/v1/datadump/link/\", path),\n        file=file,\n    )\n</code></pre>"},{"location":"references/pro/#urlscan.pro.DataDump.get_list","title":"<code>get_list(path)</code>","text":"<p>List available data dump files for a specific time window, file type, and date.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The data dump path. Format is /{time_window}/{file_type}/{date}/.         - time_window: days, hours, minutes.         - file_type: api, search, screenshots, dom.         - date: date of the data dump in YYYYMMDD format.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The list of data dump files.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from urlscan import Pro\n&gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as client:\n...     result = client.datadump.get_list(\"days/api/20260101\")\n</code></pre> Source code in <code>src/urlscan/pro/datadump.py</code> <pre><code>def get_list(self, path: str) -&gt; dict:\n    \"\"\"List available data dump files for a specific time window, file type, and date.\n\n    Args:\n        path (str): The data dump path. Format is /{time_window}/{file_type}/{date}/.\n                    - time_window: days, hours, minutes.\n                    - file_type: api, search, screenshots, dom.\n                    - date: date of the data dump in YYYYMMDD format.\n\n    Returns:\n        dict: The list of data dump files.\n\n    Examples:\n        &gt;&gt;&gt; from urlscan import Pro\n        &gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as client:\n        ...     result = client.datadump.get_list(\"days/api/20260101\")\n\n    \"\"\"\n    return self.get_json(urljoin(\"/api/v1/datadump/list/\", path))\n</code></pre>"},{"location":"references/pro/#urlscan.pro.HostnameIterator","title":"<code>urlscan.pro.HostnameIterator</code>","text":"<p>               Bases: <code>BaseIterator</code></p> <p>Hostname iterator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from urlscan import Pro\n&gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as client:\n&gt;&gt;&gt;     for result in client.hostname(\"example.com\"):\n&gt;&gt;&gt;         print(result[\"sub_id\"], result[\"data\"])\n</code></pre> Source code in <code>src/urlscan/pro/hostname.py</code> <pre><code>class HostnameIterator(BaseIterator):\n    \"\"\"Hostname iterator.\n\n    Examples:\n        &gt;&gt;&gt; from urlscan import Pro\n        &gt;&gt;&gt; with Pro(\"&lt;your_api_key&gt;\") as client:\n        &gt;&gt;&gt;     for result in client.hostname(\"example.com\"):\n        &gt;&gt;&gt;         print(result[\"sub_id\"], result[\"data\"])\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client: BaseClient,\n        *,\n        hostname: str,\n        page_state: str | None = None,\n        size: int = 1_000,\n        limit: int | None = None,\n    ):\n        \"\"\"Initialize the hostname iterator.\n\n        Args:\n            client (Client): Client.\n            hostname (str): Hostname to query.\n            page_state (str | None, optional): Page state for pagination. Defaults to None.\n            size (int, optional): Number of results returned in a search. Defaults to 1000.\n            limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n        \"\"\"\n        self._client = client\n        self._path = urljoin(\"/api/v1/hostname/\", hostname)\n        self._page_state = page_state\n        self._size = size\n        self._results: list[dict] = []\n        self._limit = limit\n        self._count = 0\n        self._has_more: bool = True\n\n    def _parse_response(self, data: dict) -&gt; tuple[list[dict], str | None]:\n        results: list[dict] = data[\"results\"]\n        page_state: str | None = data[\"pageState\"]\n        return results, page_state\n\n    def _get(self):\n        data = self._client.get_json(\n            self._path,\n            params=_compact(\n                {\n                    \"limit\": self._size,\n                    \"pageState\": self._page_state,\n                }\n            ),\n        )\n        return self._parse_response(data)\n\n    def __next__(self):\n        \"\"\"Return the next hostname observation result.\"\"\"\n        if self._limit and self._count &gt;= self._limit:\n            raise StopIteration()\n\n        if len(self._results) == 0 and self._has_more:\n            self._results, page_state = self._get()\n            self._page_state = page_state\n            self._has_more = page_state is not None\n\n        if len(self._results) == 0:\n            raise StopIteration()\n\n        result = self._results.pop(0)\n        self._count += 1\n        return result\n</code></pre>"},{"location":"references/pro/#urlscan.pro.HostnameIterator.__init__","title":"<code>__init__(client, *, hostname, page_state=None, size=1000, limit=None)</code>","text":"<p>Initialize the hostname iterator.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>Client.</p> required <code>hostname</code> <code>str</code> <p>Hostname to query.</p> required <code>page_state</code> <code>str | None</code> <p>Page state for pagination. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Number of results returned in a search. Defaults to 1000.</p> <code>1000</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> Source code in <code>src/urlscan/pro/hostname.py</code> <pre><code>def __init__(\n    self,\n    client: BaseClient,\n    *,\n    hostname: str,\n    page_state: str | None = None,\n    size: int = 1_000,\n    limit: int | None = None,\n):\n    \"\"\"Initialize the hostname iterator.\n\n    Args:\n        client (Client): Client.\n        hostname (str): Hostname to query.\n        page_state (str | None, optional): Page state for pagination. Defaults to None.\n        size (int, optional): Number of results returned in a search. Defaults to 1000.\n        limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n    \"\"\"\n    self._client = client\n    self._path = urljoin(\"/api/v1/hostname/\", hostname)\n    self._page_state = page_state\n    self._size = size\n    self._results: list[dict] = []\n    self._limit = limit\n    self._count = 0\n    self._has_more: bool = True\n</code></pre>"},{"location":"references/pro/#urlscan.pro.HostnameIterator.__next__","title":"<code>__next__()</code>","text":"<p>Return the next hostname observation result.</p> Source code in <code>src/urlscan/pro/hostname.py</code> <pre><code>def __next__(self):\n    \"\"\"Return the next hostname observation result.\"\"\"\n    if self._limit and self._count &gt;= self._limit:\n        raise StopIteration()\n\n    if len(self._results) == 0 and self._has_more:\n        self._results, page_state = self._get()\n        self._page_state = page_state\n        self._has_more = page_state is not None\n\n    if len(self._results) == 0:\n        raise StopIteration()\n\n    result = self._results.pop(0)\n    self._count += 1\n    return result\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident","title":"<code>urlscan.pro.Incident</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Incident API client.</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>class Incident(BaseClient):\n    \"\"\"Incident API client.\"\"\"\n\n    def create(\n        self,\n        *,\n        observable: str,\n        visibility: IncidentVisibilityType,\n        channels: list[str],\n        scan_interval: int | None = None,\n        scan_interval_mode: ScanIntervalModeType | None = None,\n        watched_attributes: list[WatchedAttributeType] | None = None,\n        user_agents: list[str] | None = None,\n        user_agents_per_interval: int | None = None,\n        countries: list[str] | None = None,\n        countries_per_interval: int | None = None,\n        stop_delay_suspended: int | None = None,\n        stop_delay_inactive: int | None = None,\n        stop_delay_malicious: int | None = None,\n        scan_interval_after_suspended: int | None = None,\n        scan_interval_after_malicious: int | None = None,\n        incident_profile: str | None = None,\n        expire_after: int | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Create an incident with specific options.\n\n        Args:\n            observable (str): Hostname, domain, IP, or URL to observe.\n            visibility (IncidentVisibilityType): Scan visibility (\"unlisted\" or \"private\").\n            channels (list[str]): Channels subscribed to this incident.\n            scan_interval (int | None, optional): Interval (seconds) between triggering full website scans. Defaults to None.\n            scan_interval_mode (ScanIntervalModeType | None, optional): If this is set to manual then scan_interval_after_suspended and scan_interval_after_malicious will not have an effect (\"manual\" or \"automatic\"). Defaults to None.\n            watched_attributes (list[WatchedAttributeType] | None, optional): Determine which items will be monitored for (detections, tls, dns, labels, page, meta, ip). Defaults to None.\n            user_agents (list[str] | None, optional): Browser User-Agents to use during scanning. Defaults to None.\n            user_agents_per_interval (int | None, optional): How many userAgents to use per scanInterval. Defaults to None.\n            countries (list[str] | None, optional): List of countries to scan from as ISO-3166-1 country codes. Defaults to None.\n            countries_per_interval (int | None, optional): How many countries to use per scan interval. Defaults to None.\n            stop_delay_suspended (int | None, optional): When to automatically close the incident after the observable was suspended. Defaults to None.\n            stop_delay_inactive (int | None, optional): When to automatically close the incident after the observable became inactive. Defaults to None.\n            stop_delay_malicious (int | None, optional): When to automatically close the incident after the observable became malicious. Defaults to None.\n            scan_interval_after_suspended (int | None, optional): How to change the scan interval after the observable was suspended. Defaults to None.\n            scan_interval_after_malicious (int | None, optional): How to change the scan interval after the observable became malicious. Defaults to None.\n            incident_profile (str | None, optional): ID of the incident profile to use when creating this incident. Defaults to None.\n            expire_after (int | None, optional): Seconds until the incident will automatically be closed. Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Incident body.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/createincident\n\n        \"\"\"\n        incident: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"observable\": observable,\n                    \"visibility\": visibility,\n                    \"channels\": channels,\n                    \"scanInterval\": scan_interval,\n                    \"scanIntervalMode\": scan_interval_mode,\n                    \"watchedAttributes\": watched_attributes,\n                    \"userAgents\": user_agents,\n                    \"userAgentsPerInterval\": user_agents_per_interval,\n                    \"countries\": countries,\n                    \"countriesPerInterval\": countries_per_interval,\n                    \"stopDelaySuspended\": stop_delay_suspended,\n                    \"stopDelayInactive\": stop_delay_inactive,\n                    \"stopDelayMalicious\": stop_delay_malicious,\n                    \"scanIntervalAfterSuspended\": scan_interval_after_suspended,\n                    \"scanIntervalAfterMalicious\": scan_interval_after_malicious,\n                    \"incidentProfile\": incident_profile,\n                    \"expireAfter\": expire_after,\n                },\n                kwargs,\n            )\n        )\n        data = {\"incident\": incident}\n\n        res = self._post(\"/api/v1/user/incidents\", json=data)\n        return self._response_to_json(res)\n\n    def get(self, incident_id: str) -&gt; dict:\n        \"\"\"Get details for a specific incident.\n\n        Args:\n            incident_id (str): ID of incident.\n\n        Returns:\n            dict: Incident body.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/getincident\n\n        \"\"\"\n        return super().get_json(f\"/api/v1/user/incidents/{incident_id}\")\n\n    def update(\n        self,\n        incident_id: str,\n        *,\n        observable: str,\n        visibility: IncidentVisibilityType,\n        channels: list[str],\n        scan_interval: int | None = None,\n        scan_interval_mode: ScanIntervalModeType | None = None,\n        watched_attributes: list[WatchedAttributeType] | None = None,\n        user_agents: list[str] | None = None,\n        user_agents_per_interval: int | None = None,\n        countries: list[str] | None = None,\n        countries_per_interval: int | None = None,\n        stop_delay_suspended: int | None = None,\n        stop_delay_inactive: int | None = None,\n        stop_delay_malicious: int | None = None,\n        scan_interval_after_suspended: int | None = None,\n        scan_interval_after_malicious: int | None = None,\n        incident_profile: str | None = None,\n        expire_after: int | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Update specific runtime options of the incident.\n\n        Args:\n            incident_id (str): ID of incident.\n            observable (str): Hostname, domain, IP, or URL to observe.\n            visibility (IncidentVisibilityType): Scan visibility (\"unlisted\" or \"private\").\n            channels (list[str]): Channels subscribed to this incident.\n            scan_interval (int | None, optional): Interval (seconds) between triggering full website scans. Defaults to None.\n            scan_interval_mode (ScanIntervalModeType | None, optional): If this is set to manual then scan_interval_after_suspended and scan_interval_after_malicious will not have an effect (\"manual\" or \"automatic\"). Defaults to None.\n            watched_attributes (list[WatchedAttributeType] | None, optional): Determine which items will be monitored for (detections, tls, dns, labels, page, meta, ip). Defaults to None.\n            user_agents (list[str] | None, optional): Browser User-Agents to use during scanning. Defaults to None.\n            user_agents_per_interval (int | None, optional): How many userAgents to use per scanInterval. Defaults to None.\n            countries (list[str] | None, optional): List of countries to scan from as ISO-3166-1 country codes. Defaults to None.\n            countries_per_interval (int | None, optional): How many countries to use per scan interval. Defaults to None.\n            stop_delay_suspended (int | None, optional): When to automatically close the incident after the observable was suspended. Defaults to None.\n            stop_delay_inactive (int | None, optional): When to automatically close the incident after the observable became inactive. Defaults to None.\n            stop_delay_malicious (int | None, optional): When to automatically close the incident after the observable became malicious. Defaults to None.\n            scan_interval_after_suspended (int | None, optional): How to change the scan interval after the observable was suspended. Defaults to None.\n            scan_interval_after_malicious (int | None, optional): How to change the scan interval after the observable became malicious. Defaults to None.\n            incident_profile (str | None, optional): ID of the incident profile to use when creating this incident. Defaults to None.\n            expire_after (int | None, optional): Seconds until the incident will automatically be closed. Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Incident body.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/updateincident\n\n        \"\"\"\n        incident: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"observable\": observable,\n                    \"visibility\": visibility,\n                    \"channels\": channels,\n                    \"scanInterval\": scan_interval,\n                    \"scanIntervalMode\": scan_interval_mode,\n                    \"watchedAttributes\": watched_attributes,\n                    \"userAgents\": user_agents,\n                    \"userAgentsPerInterval\": user_agents_per_interval,\n                    \"countries\": countries,\n                    \"countriesPerInterval\": countries_per_interval,\n                    \"stopDelaySuspended\": stop_delay_suspended,\n                    \"stopDelayInactive\": stop_delay_inactive,\n                    \"stopDelayMalicious\": stop_delay_malicious,\n                    \"scanIntervalAfterSuspended\": scan_interval_after_suspended,\n                    \"scanIntervalAfterMalicious\": scan_interval_after_malicious,\n                    \"incidentProfile\": incident_profile,\n                    \"expireAfter\": expire_after,\n                },\n                kwargs,\n            )\n        )\n        data = {\"incident\": incident}\n\n        res = self._put(f\"/api/v1/user/incidents/{incident_id}\", json=data)\n        return self._response_to_json(res)\n\n    def close(self, *, incident_id: str) -&gt; dict:\n        \"\"\"Close (stop) the incident.\n\n        Args:\n            incident_id (str): ID of incident.\n\n        Returns:\n            dict: Response confirming closure.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/closeincident\n\n        \"\"\"\n        res = self._put(f\"/api/v1/user/incidents/{incident_id}/close\", json={})\n        return self._response_to_json(res)\n\n    def restart(self, incident_id: str) -&gt; dict:\n        \"\"\"Restart a closed incident.\n\n        Automatically extends the incident expireAt. Starts with new incident states.\n\n        Args:\n            incident_id (str): ID of incident.\n\n        Returns:\n            dict: Response confirming restart.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/restartincident\n\n        \"\"\"\n        res = self._put(f\"/api/v1/user/incidents/{incident_id}/restart\", json={})\n        return self._response_to_json(res)\n\n    def copy(self, incident_id: str) -&gt; dict:\n        \"\"\"Copy an incident without its history.\n\n        Args:\n            incident_id (str): ID of incident.\n\n        Returns:\n            dict: Incident body.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/copyincident\n\n        \"\"\"\n        res = self._post(f\"/api/v1/user/incidents/{incident_id}/copy\", json={})\n        return self._response_to_json(res)\n\n    def fork(self, incident_id: str) -&gt; dict:\n        \"\"\"Copy an incident along with its history (incident states).\n\n        Args:\n            incident_id (str): ID of incident.\n\n        Returns:\n            dict: Incident body.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/forkincident\n\n        \"\"\"\n        res = self._post(f\"/api/v1/user/incidents/{incident_id}/fork\", json={})\n        return self._response_to_json(res)\n\n    def get_watchable_attributes(self) -&gt; dict:\n        \"\"\"Get the list of attributes which can be supplied to the watchedAttributes property of the incident.\n\n        Returns:\n            dict: List of watchable attributes.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/getwatchableattributes\n\n        \"\"\"\n        return self.get_json(\"/api/v1/user/watchableAttributes\")\n\n    def get_states(self, incident_id: str) -&gt; dict:\n        \"\"\"Retrieve individual incident states of an incident.\n\n        Args:\n            incident_id (str): ID of incident.\n\n        Returns:\n            dict: Incident states.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/incidents/getincidentstates\n\n        \"\"\"\n        return self.get_json(f\"/api/v1/user/incidentstates/{incident_id}/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.close","title":"<code>close(*, incident_id)</code>","text":"<p>Close (stop) the incident.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response confirming closure.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/closeincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def close(self, *, incident_id: str) -&gt; dict:\n    \"\"\"Close (stop) the incident.\n\n    Args:\n        incident_id (str): ID of incident.\n\n    Returns:\n        dict: Response confirming closure.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/closeincident\n\n    \"\"\"\n    res = self._put(f\"/api/v1/user/incidents/{incident_id}/close\", json={})\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.copy","title":"<code>copy(incident_id)</code>","text":"<p>Copy an incident without its history.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Incident body.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/copyincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def copy(self, incident_id: str) -&gt; dict:\n    \"\"\"Copy an incident without its history.\n\n    Args:\n        incident_id (str): ID of incident.\n\n    Returns:\n        dict: Incident body.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/copyincident\n\n    \"\"\"\n    res = self._post(f\"/api/v1/user/incidents/{incident_id}/copy\", json={})\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.create","title":"<code>create(*, observable, visibility, channels, scan_interval=None, scan_interval_mode=None, watched_attributes=None, user_agents=None, user_agents_per_interval=None, countries=None, countries_per_interval=None, stop_delay_suspended=None, stop_delay_inactive=None, stop_delay_malicious=None, scan_interval_after_suspended=None, scan_interval_after_malicious=None, incident_profile=None, expire_after=None, **kwargs)</code>","text":"<p>Create an incident with specific options.</p> <p>Parameters:</p> Name Type Description Default <code>observable</code> <code>str</code> <p>Hostname, domain, IP, or URL to observe.</p> required <code>visibility</code> <code>IncidentVisibilityType</code> <p>Scan visibility (\"unlisted\" or \"private\").</p> required <code>channels</code> <code>list[str]</code> <p>Channels subscribed to this incident.</p> required <code>scan_interval</code> <code>int | None</code> <p>Interval (seconds) between triggering full website scans. Defaults to None.</p> <code>None</code> <code>scan_interval_mode</code> <code>ScanIntervalModeType | None</code> <p>If this is set to manual then scan_interval_after_suspended and scan_interval_after_malicious will not have an effect (\"manual\" or \"automatic\"). Defaults to None.</p> <code>None</code> <code>watched_attributes</code> <code>list[WatchedAttributeType] | None</code> <p>Determine which items will be monitored for (detections, tls, dns, labels, page, meta, ip). Defaults to None.</p> <code>None</code> <code>user_agents</code> <code>list[str] | None</code> <p>Browser User-Agents to use during scanning. Defaults to None.</p> <code>None</code> <code>user_agents_per_interval</code> <code>int | None</code> <p>How many userAgents to use per scanInterval. Defaults to None.</p> <code>None</code> <code>countries</code> <code>list[str] | None</code> <p>List of countries to scan from as ISO-3166-1 country codes. Defaults to None.</p> <code>None</code> <code>countries_per_interval</code> <code>int | None</code> <p>How many countries to use per scan interval. Defaults to None.</p> <code>None</code> <code>stop_delay_suspended</code> <code>int | None</code> <p>When to automatically close the incident after the observable was suspended. Defaults to None.</p> <code>None</code> <code>stop_delay_inactive</code> <code>int | None</code> <p>When to automatically close the incident after the observable became inactive. Defaults to None.</p> <code>None</code> <code>stop_delay_malicious</code> <code>int | None</code> <p>When to automatically close the incident after the observable became malicious. Defaults to None.</p> <code>None</code> <code>scan_interval_after_suspended</code> <code>int | None</code> <p>How to change the scan interval after the observable was suspended. Defaults to None.</p> <code>None</code> <code>scan_interval_after_malicious</code> <code>int | None</code> <p>How to change the scan interval after the observable became malicious. Defaults to None.</p> <code>None</code> <code>incident_profile</code> <code>str | None</code> <p>ID of the incident profile to use when creating this incident. Defaults to None.</p> <code>None</code> <code>expire_after</code> <code>int | None</code> <p>Seconds until the incident will automatically be closed. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Incident body.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/createincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def create(\n    self,\n    *,\n    observable: str,\n    visibility: IncidentVisibilityType,\n    channels: list[str],\n    scan_interval: int | None = None,\n    scan_interval_mode: ScanIntervalModeType | None = None,\n    watched_attributes: list[WatchedAttributeType] | None = None,\n    user_agents: list[str] | None = None,\n    user_agents_per_interval: int | None = None,\n    countries: list[str] | None = None,\n    countries_per_interval: int | None = None,\n    stop_delay_suspended: int | None = None,\n    stop_delay_inactive: int | None = None,\n    stop_delay_malicious: int | None = None,\n    scan_interval_after_suspended: int | None = None,\n    scan_interval_after_malicious: int | None = None,\n    incident_profile: str | None = None,\n    expire_after: int | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Create an incident with specific options.\n\n    Args:\n        observable (str): Hostname, domain, IP, or URL to observe.\n        visibility (IncidentVisibilityType): Scan visibility (\"unlisted\" or \"private\").\n        channels (list[str]): Channels subscribed to this incident.\n        scan_interval (int | None, optional): Interval (seconds) between triggering full website scans. Defaults to None.\n        scan_interval_mode (ScanIntervalModeType | None, optional): If this is set to manual then scan_interval_after_suspended and scan_interval_after_malicious will not have an effect (\"manual\" or \"automatic\"). Defaults to None.\n        watched_attributes (list[WatchedAttributeType] | None, optional): Determine which items will be monitored for (detections, tls, dns, labels, page, meta, ip). Defaults to None.\n        user_agents (list[str] | None, optional): Browser User-Agents to use during scanning. Defaults to None.\n        user_agents_per_interval (int | None, optional): How many userAgents to use per scanInterval. Defaults to None.\n        countries (list[str] | None, optional): List of countries to scan from as ISO-3166-1 country codes. Defaults to None.\n        countries_per_interval (int | None, optional): How many countries to use per scan interval. Defaults to None.\n        stop_delay_suspended (int | None, optional): When to automatically close the incident after the observable was suspended. Defaults to None.\n        stop_delay_inactive (int | None, optional): When to automatically close the incident after the observable became inactive. Defaults to None.\n        stop_delay_malicious (int | None, optional): When to automatically close the incident after the observable became malicious. Defaults to None.\n        scan_interval_after_suspended (int | None, optional): How to change the scan interval after the observable was suspended. Defaults to None.\n        scan_interval_after_malicious (int | None, optional): How to change the scan interval after the observable became malicious. Defaults to None.\n        incident_profile (str | None, optional): ID of the incident profile to use when creating this incident. Defaults to None.\n        expire_after (int | None, optional): Seconds until the incident will automatically be closed. Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Incident body.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/createincident\n\n    \"\"\"\n    incident: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"observable\": observable,\n                \"visibility\": visibility,\n                \"channels\": channels,\n                \"scanInterval\": scan_interval,\n                \"scanIntervalMode\": scan_interval_mode,\n                \"watchedAttributes\": watched_attributes,\n                \"userAgents\": user_agents,\n                \"userAgentsPerInterval\": user_agents_per_interval,\n                \"countries\": countries,\n                \"countriesPerInterval\": countries_per_interval,\n                \"stopDelaySuspended\": stop_delay_suspended,\n                \"stopDelayInactive\": stop_delay_inactive,\n                \"stopDelayMalicious\": stop_delay_malicious,\n                \"scanIntervalAfterSuspended\": scan_interval_after_suspended,\n                \"scanIntervalAfterMalicious\": scan_interval_after_malicious,\n                \"incidentProfile\": incident_profile,\n                \"expireAfter\": expire_after,\n            },\n            kwargs,\n        )\n    )\n    data = {\"incident\": incident}\n\n    res = self._post(\"/api/v1/user/incidents\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.fork","title":"<code>fork(incident_id)</code>","text":"<p>Copy an incident along with its history (incident states).</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Incident body.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/forkincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def fork(self, incident_id: str) -&gt; dict:\n    \"\"\"Copy an incident along with its history (incident states).\n\n    Args:\n        incident_id (str): ID of incident.\n\n    Returns:\n        dict: Incident body.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/forkincident\n\n    \"\"\"\n    res = self._post(f\"/api/v1/user/incidents/{incident_id}/fork\", json={})\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.get","title":"<code>get(incident_id)</code>","text":"<p>Get details for a specific incident.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Incident body.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/getincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def get(self, incident_id: str) -&gt; dict:\n    \"\"\"Get details for a specific incident.\n\n    Args:\n        incident_id (str): ID of incident.\n\n    Returns:\n        dict: Incident body.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/getincident\n\n    \"\"\"\n    return super().get_json(f\"/api/v1/user/incidents/{incident_id}\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.get_states","title":"<code>get_states(incident_id)</code>","text":"<p>Retrieve individual incident states of an incident.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Incident states.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/getincidentstates</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def get_states(self, incident_id: str) -&gt; dict:\n    \"\"\"Retrieve individual incident states of an incident.\n\n    Args:\n        incident_id (str): ID of incident.\n\n    Returns:\n        dict: Incident states.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/getincidentstates\n\n    \"\"\"\n    return self.get_json(f\"/api/v1/user/incidentstates/{incident_id}/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.get_watchable_attributes","title":"<code>get_watchable_attributes()</code>","text":"<p>Get the list of attributes which can be supplied to the watchedAttributes property of the incident.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>List of watchable attributes.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/getwatchableattributes</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def get_watchable_attributes(self) -&gt; dict:\n    \"\"\"Get the list of attributes which can be supplied to the watchedAttributes property of the incident.\n\n    Returns:\n        dict: List of watchable attributes.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/getwatchableattributes\n\n    \"\"\"\n    return self.get_json(\"/api/v1/user/watchableAttributes\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.restart","title":"<code>restart(incident_id)</code>","text":"<p>Restart a closed incident.</p> <p>Automatically extends the incident expireAt. Starts with new incident states.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response confirming restart.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/restartincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def restart(self, incident_id: str) -&gt; dict:\n    \"\"\"Restart a closed incident.\n\n    Automatically extends the incident expireAt. Starts with new incident states.\n\n    Args:\n        incident_id (str): ID of incident.\n\n    Returns:\n        dict: Response confirming restart.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/restartincident\n\n    \"\"\"\n    res = self._put(f\"/api/v1/user/incidents/{incident_id}/restart\", json={})\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Incident.update","title":"<code>update(incident_id, *, observable, visibility, channels, scan_interval=None, scan_interval_mode=None, watched_attributes=None, user_agents=None, user_agents_per_interval=None, countries=None, countries_per_interval=None, stop_delay_suspended=None, stop_delay_inactive=None, stop_delay_malicious=None, scan_interval_after_suspended=None, scan_interval_after_malicious=None, incident_profile=None, expire_after=None, **kwargs)</code>","text":"<p>Update specific runtime options of the incident.</p> <p>Parameters:</p> Name Type Description Default <code>incident_id</code> <code>str</code> <p>ID of incident.</p> required <code>observable</code> <code>str</code> <p>Hostname, domain, IP, or URL to observe.</p> required <code>visibility</code> <code>IncidentVisibilityType</code> <p>Scan visibility (\"unlisted\" or \"private\").</p> required <code>channels</code> <code>list[str]</code> <p>Channels subscribed to this incident.</p> required <code>scan_interval</code> <code>int | None</code> <p>Interval (seconds) between triggering full website scans. Defaults to None.</p> <code>None</code> <code>scan_interval_mode</code> <code>ScanIntervalModeType | None</code> <p>If this is set to manual then scan_interval_after_suspended and scan_interval_after_malicious will not have an effect (\"manual\" or \"automatic\"). Defaults to None.</p> <code>None</code> <code>watched_attributes</code> <code>list[WatchedAttributeType] | None</code> <p>Determine which items will be monitored for (detections, tls, dns, labels, page, meta, ip). Defaults to None.</p> <code>None</code> <code>user_agents</code> <code>list[str] | None</code> <p>Browser User-Agents to use during scanning. Defaults to None.</p> <code>None</code> <code>user_agents_per_interval</code> <code>int | None</code> <p>How many userAgents to use per scanInterval. Defaults to None.</p> <code>None</code> <code>countries</code> <code>list[str] | None</code> <p>List of countries to scan from as ISO-3166-1 country codes. Defaults to None.</p> <code>None</code> <code>countries_per_interval</code> <code>int | None</code> <p>How many countries to use per scan interval. Defaults to None.</p> <code>None</code> <code>stop_delay_suspended</code> <code>int | None</code> <p>When to automatically close the incident after the observable was suspended. Defaults to None.</p> <code>None</code> <code>stop_delay_inactive</code> <code>int | None</code> <p>When to automatically close the incident after the observable became inactive. Defaults to None.</p> <code>None</code> <code>stop_delay_malicious</code> <code>int | None</code> <p>When to automatically close the incident after the observable became malicious. Defaults to None.</p> <code>None</code> <code>scan_interval_after_suspended</code> <code>int | None</code> <p>How to change the scan interval after the observable was suspended. Defaults to None.</p> <code>None</code> <code>scan_interval_after_malicious</code> <code>int | None</code> <p>How to change the scan interval after the observable became malicious. Defaults to None.</p> <code>None</code> <code>incident_profile</code> <code>str | None</code> <p>ID of the incident profile to use when creating this incident. Defaults to None.</p> <code>None</code> <code>expire_after</code> <code>int | None</code> <p>Seconds until the incident will automatically be closed. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Incident body.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/incidents/updateincident</p> Source code in <code>src/urlscan/pro/incident.py</code> <pre><code>def update(\n    self,\n    incident_id: str,\n    *,\n    observable: str,\n    visibility: IncidentVisibilityType,\n    channels: list[str],\n    scan_interval: int | None = None,\n    scan_interval_mode: ScanIntervalModeType | None = None,\n    watched_attributes: list[WatchedAttributeType] | None = None,\n    user_agents: list[str] | None = None,\n    user_agents_per_interval: int | None = None,\n    countries: list[str] | None = None,\n    countries_per_interval: int | None = None,\n    stop_delay_suspended: int | None = None,\n    stop_delay_inactive: int | None = None,\n    stop_delay_malicious: int | None = None,\n    scan_interval_after_suspended: int | None = None,\n    scan_interval_after_malicious: int | None = None,\n    incident_profile: str | None = None,\n    expire_after: int | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Update specific runtime options of the incident.\n\n    Args:\n        incident_id (str): ID of incident.\n        observable (str): Hostname, domain, IP, or URL to observe.\n        visibility (IncidentVisibilityType): Scan visibility (\"unlisted\" or \"private\").\n        channels (list[str]): Channels subscribed to this incident.\n        scan_interval (int | None, optional): Interval (seconds) between triggering full website scans. Defaults to None.\n        scan_interval_mode (ScanIntervalModeType | None, optional): If this is set to manual then scan_interval_after_suspended and scan_interval_after_malicious will not have an effect (\"manual\" or \"automatic\"). Defaults to None.\n        watched_attributes (list[WatchedAttributeType] | None, optional): Determine which items will be monitored for (detections, tls, dns, labels, page, meta, ip). Defaults to None.\n        user_agents (list[str] | None, optional): Browser User-Agents to use during scanning. Defaults to None.\n        user_agents_per_interval (int | None, optional): How many userAgents to use per scanInterval. Defaults to None.\n        countries (list[str] | None, optional): List of countries to scan from as ISO-3166-1 country codes. Defaults to None.\n        countries_per_interval (int | None, optional): How many countries to use per scan interval. Defaults to None.\n        stop_delay_suspended (int | None, optional): When to automatically close the incident after the observable was suspended. Defaults to None.\n        stop_delay_inactive (int | None, optional): When to automatically close the incident after the observable became inactive. Defaults to None.\n        stop_delay_malicious (int | None, optional): When to automatically close the incident after the observable became malicious. Defaults to None.\n        scan_interval_after_suspended (int | None, optional): How to change the scan interval after the observable was suspended. Defaults to None.\n        scan_interval_after_malicious (int | None, optional): How to change the scan interval after the observable became malicious. Defaults to None.\n        incident_profile (str | None, optional): ID of the incident profile to use when creating this incident. Defaults to None.\n        expire_after (int | None, optional): Seconds until the incident will automatically be closed. Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Incident body.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/incidents/updateincident\n\n    \"\"\"\n    incident: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"observable\": observable,\n                \"visibility\": visibility,\n                \"channels\": channels,\n                \"scanInterval\": scan_interval,\n                \"scanIntervalMode\": scan_interval_mode,\n                \"watchedAttributes\": watched_attributes,\n                \"userAgents\": user_agents,\n                \"userAgentsPerInterval\": user_agents_per_interval,\n                \"countries\": countries,\n                \"countriesPerInterval\": countries_per_interval,\n                \"stopDelaySuspended\": stop_delay_suspended,\n                \"stopDelayInactive\": stop_delay_inactive,\n                \"stopDelayMalicious\": stop_delay_malicious,\n                \"scanIntervalAfterSuspended\": scan_interval_after_suspended,\n                \"scanIntervalAfterMalicious\": scan_interval_after_malicious,\n                \"incidentProfile\": incident_profile,\n                \"expireAfter\": expire_after,\n            },\n            kwargs,\n        )\n    )\n    data = {\"incident\": incident}\n\n    res = self._put(f\"/api/v1/user/incidents/{incident_id}\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan","title":"<code>urlscan.pro.LiveScan</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Live scanning API client.</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>class LiveScan(BaseClient):\n    \"\"\"Live scanning API client.\"\"\"\n\n    def get_scanners(self) -&gt; dict:\n        \"\"\"Get a list of available Live Scanning nodes along with their current metadata.\n\n        Returns:\n            dict: List of available scanners with metadata.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanscanners\n\n        \"\"\"\n        return self.get_json(\"/api/v1/livescan/scanners/\")\n\n    def task(\n        self,\n        url: str,\n        *,\n        scanner_id: str,\n        visibility: VisibilityType | None = None,\n        page_timeout: int | None = None,\n        capture_delay: int | None = None,\n        extra_headers: dict[str, str] | None = None,\n        enable_features: list[str] | None = None,\n        disable_features: list[str] | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Task a URL to be scanned.\n\n        The HTTP request will return with the scan UUID immediately and then it is your responsibility to poll the result resource type until the scan has finished.\n\n        Args:\n            url (str): URL to scan.\n            scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n            visibility (VisibilityType | None, optional): Visibility of the scan. Defaults to None.\n            page_timeout (int | None, optional): Time to wait for the whole scan process (in ms). Defaults to None.\n            capture_delay (int | None, optional): Delay after page load before capturing (in ms). Defaults to None.\n            extra_headers (dict[str, str] | None, optional): Extra HTTP headers. Defaults to None.\n            enable_features (list[str] | None, optional): Features to enable. Defaults to None.\n            disable_features (list[str] | None, optional): Features to disable. Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Response containing the scan UUID.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescantask\n\n        \"\"\"\n        task: dict[str, Any] = _compact(\n            {\n                \"url\": url,\n                \"visibility\": visibility,\n            }\n        )\n        scanner: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"pageTimeout\": page_timeout,\n                    \"captureDelay\": capture_delay,\n                    \"extraHeaders\": extra_headers,\n                    \"enableFeatures\": enable_features,\n                    \"disableFeatures\": disable_features,\n                },\n                kwargs,\n            )\n        )\n        data: dict[str, Any] = {\"task\": task, \"scanner\": scanner}\n\n        res = self._post(f\"/api/v1/livescan/{scanner_id}/task/\", json=data)\n        return self._response_to_json(res)\n\n    def scan(\n        self,\n        url: str,\n        *,\n        scanner_id: str,\n        visibility: VisibilityType | None = None,\n        page_timeout: int | None = None,\n        capture_delay: int | None = None,\n        extra_headers: dict[str, str] | None = None,\n        enable_features: list[str] | None = None,\n        disable_features: list[str] | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Task a URL to be scanned. The HTTP request will block until the scan has finished.\n\n        Args:\n            url (str): URL to scan.\n            scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n            visibility (VisibilityType | None, optional): Visibility of the scan. Defaults to None.\n            page_timeout (int | None, optional): Time to wait for the whole scan process (in ms). Defaults to None.\n            capture_delay (int | None, optional): Delay after page load before capturing (in ms). Defaults to None.\n            extra_headers (dict[str, str] | None, optional): Extra HTTP headers. Defaults to None.\n            enable_features (list[str] | None, optional): Features to enable. Defaults to None.\n            disable_features (list[str] | None, optional): Features to disable. Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Response containing the scan UUID.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanscan\n\n        \"\"\"\n        task: dict[str, Any] = _compact(\n            {\n                \"url\": url,\n                \"visibility\": visibility,\n            }\n        )\n        scanner: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"pageTimeout\": page_timeout,\n                    \"captureDelay\": capture_delay,\n                    \"extraHeaders\": extra_headers,\n                    \"enableFeatures\": enable_features,\n                    \"disableFeatures\": disable_features,\n                },\n                kwargs,\n            )\n        )\n        data: dict[str, Any] = {\"task\": task, \"scanner\": scanner}\n\n        res = self._post(f\"/api/v1/livescan/{scanner_id}/scan/\", json=data)\n        return self._response_to_json(res)\n\n    def get_resource(\n        self,\n        *,\n        scanner_id: str,\n        resource_type: LiveScanResourceType,\n        resource_id: str,\n    ) -&gt; Any:\n        \"\"\"Retrieve the resource for a particular scan ID or SHA256 from this live scanner.\n\n        Args:\n            scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n            resource_type (LiveScanResourceType): Type of resource (\"result\", \"screenshot\", \"dom\", \"response\", or \"download\").\n            resource_id (str): Resource ID. For result/screenshot/dom: UUID of the scan. For response/download: SHA256 of the resource.\n\n        Returns:\n            Any: Resource content. Returns dict for \"result\", str for \"dom\", bytes for binary resources.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescangetresource\n\n        \"\"\"\n        path = f\"/api/v1/livescan/{scanner_id}/{resource_type}/{resource_id}\"\n\n        if resource_type == \"result\":\n            return self.get_json(path)\n\n        if resource_type in (\"screenshot\", \"response\", \"download\"):\n            return self.get_content(path)\n\n        if resource_type == \"dom\":\n            return self.get_text(path)\n\n        return self._get(path)\n\n    def store(\n        self,\n        *,\n        scanner_id: str,\n        scan_id: str,\n        visibility: VisibilityType,\n    ) -&gt; dict:\n        \"\"\"Store the temporary scan as a permanent snapshot on urlscan.io.\n\n        Args:\n            scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n            scan_id (str): Scan UUID.\n            visibility (VisibilityType): Visibility for the stored scan (\"public\", \"private\", or \"unlisted\").\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanstore\n\n        \"\"\"\n        data = {\"task\": {\"visibility\": visibility}}\n        res = self._put(f\"/api/v1/livescan/{scanner_id}/{scan_id}/\", json=data)\n        return self._response_to_json(res)\n\n    def purge(\n        self,\n        *,\n        scanner_id: str,\n        scan_id: str,\n    ) -&gt; dict:\n        \"\"\"Purge temporary scan from scanner immediately. Scans will be automatically purged after 60 minutes.\n\n        Args:\n            scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n            scan_id (str): Scan UUID.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescandiscard\n\n        \"\"\"\n        res = self._delete(f\"/api/v1/livescan/{scanner_id}/{scan_id}/\")\n        return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan.get_resource","title":"<code>get_resource(*, scanner_id, resource_type, resource_id)</code>","text":"<p>Retrieve the resource for a particular scan ID or SHA256 from this live scanner.</p> <p>Parameters:</p> Name Type Description Default <code>scanner_id</code> <code>str</code> <p>Scanner ID (e.g., \"de01\" for Germany).</p> required <code>resource_type</code> <code>LiveScanResourceType</code> <p>Type of resource (\"result\", \"screenshot\", \"dom\", \"response\", or \"download\").</p> required <code>resource_id</code> <code>str</code> <p>Resource ID. For result/screenshot/dom: UUID of the scan. For response/download: SHA256 of the resource.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Resource content. Returns dict for \"result\", str for \"dom\", bytes for binary resources.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescangetresource</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>def get_resource(\n    self,\n    *,\n    scanner_id: str,\n    resource_type: LiveScanResourceType,\n    resource_id: str,\n) -&gt; Any:\n    \"\"\"Retrieve the resource for a particular scan ID or SHA256 from this live scanner.\n\n    Args:\n        scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n        resource_type (LiveScanResourceType): Type of resource (\"result\", \"screenshot\", \"dom\", \"response\", or \"download\").\n        resource_id (str): Resource ID. For result/screenshot/dom: UUID of the scan. For response/download: SHA256 of the resource.\n\n    Returns:\n        Any: Resource content. Returns dict for \"result\", str for \"dom\", bytes for binary resources.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescangetresource\n\n    \"\"\"\n    path = f\"/api/v1/livescan/{scanner_id}/{resource_type}/{resource_id}\"\n\n    if resource_type == \"result\":\n        return self.get_json(path)\n\n    if resource_type in (\"screenshot\", \"response\", \"download\"):\n        return self.get_content(path)\n\n    if resource_type == \"dom\":\n        return self.get_text(path)\n\n    return self._get(path)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan.get_scanners","title":"<code>get_scanners()</code>","text":"<p>Get a list of available Live Scanning nodes along with their current metadata.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>List of available scanners with metadata.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanscanners</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>def get_scanners(self) -&gt; dict:\n    \"\"\"Get a list of available Live Scanning nodes along with their current metadata.\n\n    Returns:\n        dict: List of available scanners with metadata.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanscanners\n\n    \"\"\"\n    return self.get_json(\"/api/v1/livescan/scanners/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan.purge","title":"<code>purge(*, scanner_id, scan_id)</code>","text":"<p>Purge temporary scan from scanner immediately. Scans will be automatically purged after 60 minutes.</p> <p>Parameters:</p> Name Type Description Default <code>scanner_id</code> <code>str</code> <p>Scanner ID (e.g., \"de01\" for Germany).</p> required <code>scan_id</code> <code>str</code> <p>Scan UUID.</p> required Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescandiscard</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>def purge(\n    self,\n    *,\n    scanner_id: str,\n    scan_id: str,\n) -&gt; dict:\n    \"\"\"Purge temporary scan from scanner immediately. Scans will be automatically purged after 60 minutes.\n\n    Args:\n        scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n        scan_id (str): Scan UUID.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescandiscard\n\n    \"\"\"\n    res = self._delete(f\"/api/v1/livescan/{scanner_id}/{scan_id}/\")\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan.scan","title":"<code>scan(url, *, scanner_id, visibility=None, page_timeout=None, capture_delay=None, extra_headers=None, enable_features=None, disable_features=None, **kwargs)</code>","text":"<p>Task a URL to be scanned. The HTTP request will block until the scan has finished.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to scan.</p> required <code>scanner_id</code> <code>str</code> <p>Scanner ID (e.g., \"de01\" for Germany).</p> required <code>visibility</code> <code>VisibilityType | None</code> <p>Visibility of the scan. Defaults to None.</p> <code>None</code> <code>page_timeout</code> <code>int | None</code> <p>Time to wait for the whole scan process (in ms). Defaults to None.</p> <code>None</code> <code>capture_delay</code> <code>int | None</code> <p>Delay after page load before capturing (in ms). Defaults to None.</p> <code>None</code> <code>extra_headers</code> <code>dict[str, str] | None</code> <p>Extra HTTP headers. Defaults to None.</p> <code>None</code> <code>enable_features</code> <code>list[str] | None</code> <p>Features to enable. Defaults to None.</p> <code>None</code> <code>disable_features</code> <code>list[str] | None</code> <p>Features to disable. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing the scan UUID.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanscan</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>def scan(\n    self,\n    url: str,\n    *,\n    scanner_id: str,\n    visibility: VisibilityType | None = None,\n    page_timeout: int | None = None,\n    capture_delay: int | None = None,\n    extra_headers: dict[str, str] | None = None,\n    enable_features: list[str] | None = None,\n    disable_features: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Task a URL to be scanned. The HTTP request will block until the scan has finished.\n\n    Args:\n        url (str): URL to scan.\n        scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n        visibility (VisibilityType | None, optional): Visibility of the scan. Defaults to None.\n        page_timeout (int | None, optional): Time to wait for the whole scan process (in ms). Defaults to None.\n        capture_delay (int | None, optional): Delay after page load before capturing (in ms). Defaults to None.\n        extra_headers (dict[str, str] | None, optional): Extra HTTP headers. Defaults to None.\n        enable_features (list[str] | None, optional): Features to enable. Defaults to None.\n        disable_features (list[str] | None, optional): Features to disable. Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Response containing the scan UUID.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanscan\n\n    \"\"\"\n    task: dict[str, Any] = _compact(\n        {\n            \"url\": url,\n            \"visibility\": visibility,\n        }\n    )\n    scanner: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"pageTimeout\": page_timeout,\n                \"captureDelay\": capture_delay,\n                \"extraHeaders\": extra_headers,\n                \"enableFeatures\": enable_features,\n                \"disableFeatures\": disable_features,\n            },\n            kwargs,\n        )\n    )\n    data: dict[str, Any] = {\"task\": task, \"scanner\": scanner}\n\n    res = self._post(f\"/api/v1/livescan/{scanner_id}/scan/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan.store","title":"<code>store(*, scanner_id, scan_id, visibility)</code>","text":"<p>Store the temporary scan as a permanent snapshot on urlscan.io.</p> <p>Parameters:</p> Name Type Description Default <code>scanner_id</code> <code>str</code> <p>Scanner ID (e.g., \"de01\" for Germany).</p> required <code>scan_id</code> <code>str</code> <p>Scan UUID.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility for the stored scan (\"public\", \"private\", or \"unlisted\").</p> required Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanstore</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>def store(\n    self,\n    *,\n    scanner_id: str,\n    scan_id: str,\n    visibility: VisibilityType,\n) -&gt; dict:\n    \"\"\"Store the temporary scan as a permanent snapshot on urlscan.io.\n\n    Args:\n        scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n        scan_id (str): Scan UUID.\n        visibility (VisibilityType): Visibility for the stored scan (\"public\", \"private\", or \"unlisted\").\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescanstore\n\n    \"\"\"\n    data = {\"task\": {\"visibility\": visibility}}\n    res = self._put(f\"/api/v1/livescan/{scanner_id}/{scan_id}/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.LiveScan.task","title":"<code>task(url, *, scanner_id, visibility=None, page_timeout=None, capture_delay=None, extra_headers=None, enable_features=None, disable_features=None, **kwargs)</code>","text":"<p>Task a URL to be scanned.</p> <p>The HTTP request will return with the scan UUID immediately and then it is your responsibility to poll the result resource type until the scan has finished.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to scan.</p> required <code>scanner_id</code> <code>str</code> <p>Scanner ID (e.g., \"de01\" for Germany).</p> required <code>visibility</code> <code>VisibilityType | None</code> <p>Visibility of the scan. Defaults to None.</p> <code>None</code> <code>page_timeout</code> <code>int | None</code> <p>Time to wait for the whole scan process (in ms). Defaults to None.</p> <code>None</code> <code>capture_delay</code> <code>int | None</code> <p>Delay after page load before capturing (in ms). Defaults to None.</p> <code>None</code> <code>extra_headers</code> <code>dict[str, str] | None</code> <p>Extra HTTP headers. Defaults to None.</p> <code>None</code> <code>enable_features</code> <code>list[str] | None</code> <p>Features to enable. Defaults to None.</p> <code>None</code> <code>disable_features</code> <code>list[str] | None</code> <p>Features to disable. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing the scan UUID.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescantask</p> Source code in <code>src/urlscan/pro/livescan.py</code> <pre><code>def task(\n    self,\n    url: str,\n    *,\n    scanner_id: str,\n    visibility: VisibilityType | None = None,\n    page_timeout: int | None = None,\n    capture_delay: int | None = None,\n    extra_headers: dict[str, str] | None = None,\n    enable_features: list[str] | None = None,\n    disable_features: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Task a URL to be scanned.\n\n    The HTTP request will return with the scan UUID immediately and then it is your responsibility to poll the result resource type until the scan has finished.\n\n    Args:\n        url (str): URL to scan.\n        scanner_id (str): Scanner ID (e.g., \"de01\" for Germany).\n        visibility (VisibilityType | None, optional): Visibility of the scan. Defaults to None.\n        page_timeout (int | None, optional): Time to wait for the whole scan process (in ms). Defaults to None.\n        capture_delay (int | None, optional): Delay after page load before capturing (in ms). Defaults to None.\n        extra_headers (dict[str, str] | None, optional): Extra HTTP headers. Defaults to None.\n        enable_features (list[str] | None, optional): Features to enable. Defaults to None.\n        disable_features (list[str] | None, optional): Features to disable. Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Response containing the scan UUID.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/live-scanning/livescantask\n\n    \"\"\"\n    task: dict[str, Any] = _compact(\n        {\n            \"url\": url,\n            \"visibility\": visibility,\n        }\n    )\n    scanner: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"pageTimeout\": page_timeout,\n                \"captureDelay\": capture_delay,\n                \"extraHeaders\": extra_headers,\n                \"enableFeatures\": enable_features,\n                \"disableFeatures\": disable_features,\n            },\n            kwargs,\n        )\n    )\n    data: dict[str, Any] = {\"task\": task, \"scanner\": scanner}\n\n    res = self._post(f\"/api/v1/livescan/{scanner_id}/task/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.SavedSearch","title":"<code>urlscan.pro.SavedSearch</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Saved Search API client.</p> Source code in <code>src/urlscan/pro/saved_search.py</code> <pre><code>class SavedSearch(BaseClient):\n    \"\"\"Saved Search API client.\"\"\"\n\n    def get_list(self) -&gt; dict:\n        \"\"\"Get a list of Saved Searches for the current user.\n\n        Returns:\n            dict: Response containing an array of Saved Search objects with their properties.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-get\n\n        \"\"\"\n        return self.get_json(\"/api/v1/user/searches/\")\n\n    def create(\n        self,\n        *,\n        datasource: SavedSearchDataSource,\n        query: str,\n        name: str,\n        description: str | None = None,\n        long_description: str | None = None,\n        tlp: TLPType | None = None,\n        user_tags: list[str] | None = None,\n        permissions: list[PermissionType] | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Create a Saved Search.\n\n        Args:\n            datasource (SavedSearchDataSource): Which data this Saved Search operates on\n                (\"hostnames\" or \"scans\").\n            query (str): Search API query string.\n            name (str): User-facing short name for the saved search.\n            description (str | None, optional): Short description. Defaults to None.\n            long_description (str | None, optional): Long description. Defaults to None.\n            tlp (TLPType | None, optional): TLP (Traffic Light Protocol) indicator for\n                other users on the urlscan Pro platform. Valid values: \"red\", \"amber+strict\",\n                \"amber\", \"green\", \"clear\". Defaults to None.\n            user_tags (list[str] | None, optional): User-supplied tags to be applied to\n                matching items. Apply the following prefixes to tags to define their\n                visibility scope: `pro.` (urlscan Pro users), `public.` (all registered\n                users), `private.` (only you), or `team.` (you and team members).\n                Defaults to None.\n            permissions (list[PermissionType] | None, optional): Determine whether only\n                other users on the same team or everyone on urlscan Pro can see the search.\n                Valid values: \"public:read\", \"team:read\", \"team:write\". Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Created Saved Search object containing the search properties and unique _id.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-post\n\n        \"\"\"\n        search: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"datasource\": datasource,\n                    \"query\": query,\n                    \"name\": name,\n                    \"description\": description,\n                    \"longDescription\": long_description,\n                    \"tlp\": tlp,\n                    \"userTags\": user_tags,\n                    \"permissions\": permissions,\n                },\n                kwargs,\n            )\n        )\n        data: dict[str, Any] = {\"search\": search}\n\n        res = self._post(\"/api/v1/user/searches/\", json=data)\n        return self._response_to_json(res)\n\n    def update(\n        self,\n        search_id: str,\n        *,\n        datasource: SavedSearchDataSource,\n        query: str,\n        name: str,\n        description: str | None = None,\n        long_description: str | None = None,\n        tlp: TLPType | None = None,\n        user_tags: list[str] | None = None,\n        permissions: list[PermissionType] | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Update a Saved Search.\n\n        Args:\n            search_id (str): Unique ID of the saved search to update.\n            datasource (SavedSearchDataSource): Which data this Saved Search operates on\n                (\"hostnames\" or \"scans\").\n            query (str): Search API query string.\n            name (str): User-facing short name for the saved search.\n            description (str | None, optional): Short description. Defaults to None.\n            long_description (str | None, optional): Long description. Defaults to None.\n            tlp (TLPType | None, optional): TLP (Traffic Light Protocol) indicator for\n                other users on the urlscan Pro platform. Valid values: \"red\", \"amber+strict\",\n                \"amber\", \"green\", \"clear\". Defaults to None.\n            user_tags (list[str] | None, optional): User-supplied tags to be applied to\n                matching items. Apply the following prefixes to tags to define their\n                visibility scope: `pro.` (urlscan Pro users), `public.` (all registered\n                users), `private.` (only you), or `team.` (you and team members).\n                Defaults to None.\n            permissions (list[PermissionType] | None, optional): Determine whether only\n                other users on the same team or everyone on urlscan Pro can see the search.\n                Valid values: \"public:read\", \"team:read\", \"team:write\". Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Updated Saved Search object containing the search properties and unique _id.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-put\n\n        \"\"\"\n        search: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"datasource\": datasource,\n                    \"query\": query,\n                    \"name\": name,\n                    \"description\": description,\n                    \"longDescription\": long_description,\n                    \"tlp\": tlp,\n                    \"userTags\": user_tags,\n                    \"permissions\": permissions,\n                },\n                kwargs,\n            )\n        )\n        data: dict[str, Any] = {\"search\": search}\n\n        res = self._put(f\"/api/v1/user/searches/{search_id}/\", json=data)\n        return self._response_to_json(res)\n\n    def remove(self, search_id: str) -&gt; dict:\n        \"\"\"Delete a Saved Search.\n\n        Args:\n            search_id (str): Unique ID of the saved search to delete.\n\n        Returns:\n            dict: Empty JSON object on success.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-delete\n\n        \"\"\"\n        res = super()._delete(f\"/api/v1/user/searches/{search_id}/\")\n        return self._response_to_json(res)\n\n    def get_results(self, search_id: str) -&gt; dict:\n        \"\"\"Get the search results for a specific Saved Search.\n\n        Args:\n            search_id (str): Unique ID of the saved search.\n\n        Returns:\n            dict: Search results matching the saved query. The structure depends on the\n                datasource (hostnames or scans) specified in the saved search.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-results\n\n        \"\"\"\n        return self.get_json(f\"/api/v1/user/searches/{search_id}/results/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.SavedSearch.create","title":"<code>create(*, datasource, query, name, description=None, long_description=None, tlp=None, user_tags=None, permissions=None, **kwargs)</code>","text":"<p>Create a Saved Search.</p> <p>Parameters:</p> Name Type Description Default <code>datasource</code> <code>SavedSearchDataSource</code> <p>Which data this Saved Search operates on (\"hostnames\" or \"scans\").</p> required <code>query</code> <code>str</code> <p>Search API query string.</p> required <code>name</code> <code>str</code> <p>User-facing short name for the saved search.</p> required <code>description</code> <code>str | None</code> <p>Short description. Defaults to None.</p> <code>None</code> <code>long_description</code> <code>str | None</code> <p>Long description. Defaults to None.</p> <code>None</code> <code>tlp</code> <code>TLPType | None</code> <p>TLP (Traffic Light Protocol) indicator for other users on the urlscan Pro platform. Valid values: \"red\", \"amber+strict\", \"amber\", \"green\", \"clear\". Defaults to None.</p> <code>None</code> <code>user_tags</code> <code>list[str] | None</code> <p>User-supplied tags to be applied to matching items. Apply the following prefixes to tags to define their visibility scope: <code>pro.</code> (urlscan Pro users), <code>public.</code> (all registered users), <code>private.</code> (only you), or <code>team.</code> (you and team members). Defaults to None.</p> <code>None</code> <code>permissions</code> <code>list[PermissionType] | None</code> <p>Determine whether only other users on the same team or everyone on urlscan Pro can see the search. Valid values: \"public:read\", \"team:read\", \"team:write\". Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Created Saved Search object containing the search properties and unique _id.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-post</p> Source code in <code>src/urlscan/pro/saved_search.py</code> <pre><code>def create(\n    self,\n    *,\n    datasource: SavedSearchDataSource,\n    query: str,\n    name: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    tlp: TLPType | None = None,\n    user_tags: list[str] | None = None,\n    permissions: list[PermissionType] | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Create a Saved Search.\n\n    Args:\n        datasource (SavedSearchDataSource): Which data this Saved Search operates on\n            (\"hostnames\" or \"scans\").\n        query (str): Search API query string.\n        name (str): User-facing short name for the saved search.\n        description (str | None, optional): Short description. Defaults to None.\n        long_description (str | None, optional): Long description. Defaults to None.\n        tlp (TLPType | None, optional): TLP (Traffic Light Protocol) indicator for\n            other users on the urlscan Pro platform. Valid values: \"red\", \"amber+strict\",\n            \"amber\", \"green\", \"clear\". Defaults to None.\n        user_tags (list[str] | None, optional): User-supplied tags to be applied to\n            matching items. Apply the following prefixes to tags to define their\n            visibility scope: `pro.` (urlscan Pro users), `public.` (all registered\n            users), `private.` (only you), or `team.` (you and team members).\n            Defaults to None.\n        permissions (list[PermissionType] | None, optional): Determine whether only\n            other users on the same team or everyone on urlscan Pro can see the search.\n            Valid values: \"public:read\", \"team:read\", \"team:write\". Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Created Saved Search object containing the search properties and unique _id.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-post\n\n    \"\"\"\n    search: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"datasource\": datasource,\n                \"query\": query,\n                \"name\": name,\n                \"description\": description,\n                \"longDescription\": long_description,\n                \"tlp\": tlp,\n                \"userTags\": user_tags,\n                \"permissions\": permissions,\n            },\n            kwargs,\n        )\n    )\n    data: dict[str, Any] = {\"search\": search}\n\n    res = self._post(\"/api/v1/user/searches/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.SavedSearch.get_list","title":"<code>get_list()</code>","text":"<p>Get a list of Saved Searches for the current user.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing an array of Saved Search objects with their properties.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-get</p> Source code in <code>src/urlscan/pro/saved_search.py</code> <pre><code>def get_list(self) -&gt; dict:\n    \"\"\"Get a list of Saved Searches for the current user.\n\n    Returns:\n        dict: Response containing an array of Saved Search objects with their properties.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-get\n\n    \"\"\"\n    return self.get_json(\"/api/v1/user/searches/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.SavedSearch.get_results","title":"<code>get_results(search_id)</code>","text":"<p>Get the search results for a specific Saved Search.</p> <p>Parameters:</p> Name Type Description Default <code>search_id</code> <code>str</code> <p>Unique ID of the saved search.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Search results matching the saved query. The structure depends on the datasource (hostnames or scans) specified in the saved search.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-results</p> Source code in <code>src/urlscan/pro/saved_search.py</code> <pre><code>def get_results(self, search_id: str) -&gt; dict:\n    \"\"\"Get the search results for a specific Saved Search.\n\n    Args:\n        search_id (str): Unique ID of the saved search.\n\n    Returns:\n        dict: Search results matching the saved query. The structure depends on the\n            datasource (hostnames or scans) specified in the saved search.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-results\n\n    \"\"\"\n    return self.get_json(f\"/api/v1/user/searches/{search_id}/results/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.SavedSearch.remove","title":"<code>remove(search_id)</code>","text":"<p>Delete a Saved Search.</p> <p>Parameters:</p> Name Type Description Default <code>search_id</code> <code>str</code> <p>Unique ID of the saved search to delete.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Empty JSON object on success.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-delete</p> Source code in <code>src/urlscan/pro/saved_search.py</code> <pre><code>def remove(self, search_id: str) -&gt; dict:\n    \"\"\"Delete a Saved Search.\n\n    Args:\n        search_id (str): Unique ID of the saved search to delete.\n\n    Returns:\n        dict: Empty JSON object on success.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-delete\n\n    \"\"\"\n    res = super()._delete(f\"/api/v1/user/searches/{search_id}/\")\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.SavedSearch.update","title":"<code>update(search_id, *, datasource, query, name, description=None, long_description=None, tlp=None, user_tags=None, permissions=None, **kwargs)</code>","text":"<p>Update a Saved Search.</p> <p>Parameters:</p> Name Type Description Default <code>search_id</code> <code>str</code> <p>Unique ID of the saved search to update.</p> required <code>datasource</code> <code>SavedSearchDataSource</code> <p>Which data this Saved Search operates on (\"hostnames\" or \"scans\").</p> required <code>query</code> <code>str</code> <p>Search API query string.</p> required <code>name</code> <code>str</code> <p>User-facing short name for the saved search.</p> required <code>description</code> <code>str | None</code> <p>Short description. Defaults to None.</p> <code>None</code> <code>long_description</code> <code>str | None</code> <p>Long description. Defaults to None.</p> <code>None</code> <code>tlp</code> <code>TLPType | None</code> <p>TLP (Traffic Light Protocol) indicator for other users on the urlscan Pro platform. Valid values: \"red\", \"amber+strict\", \"amber\", \"green\", \"clear\". Defaults to None.</p> <code>None</code> <code>user_tags</code> <code>list[str] | None</code> <p>User-supplied tags to be applied to matching items. Apply the following prefixes to tags to define their visibility scope: <code>pro.</code> (urlscan Pro users), <code>public.</code> (all registered users), <code>private.</code> (only you), or <code>team.</code> (you and team members). Defaults to None.</p> <code>None</code> <code>permissions</code> <code>list[PermissionType] | None</code> <p>Determine whether only other users on the same team or everyone on urlscan Pro can see the search. Valid values: \"public:read\", \"team:read\", \"team:write\". Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Updated Saved Search object containing the search properties and unique _id.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-put</p> Source code in <code>src/urlscan/pro/saved_search.py</code> <pre><code>def update(\n    self,\n    search_id: str,\n    *,\n    datasource: SavedSearchDataSource,\n    query: str,\n    name: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    tlp: TLPType | None = None,\n    user_tags: list[str] | None = None,\n    permissions: list[PermissionType] | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Update a Saved Search.\n\n    Args:\n        search_id (str): Unique ID of the saved search to update.\n        datasource (SavedSearchDataSource): Which data this Saved Search operates on\n            (\"hostnames\" or \"scans\").\n        query (str): Search API query string.\n        name (str): User-facing short name for the saved search.\n        description (str | None, optional): Short description. Defaults to None.\n        long_description (str | None, optional): Long description. Defaults to None.\n        tlp (TLPType | None, optional): TLP (Traffic Light Protocol) indicator for\n            other users on the urlscan Pro platform. Valid values: \"red\", \"amber+strict\",\n            \"amber\", \"green\", \"clear\". Defaults to None.\n        user_tags (list[str] | None, optional): User-supplied tags to be applied to\n            matching items. Apply the following prefixes to tags to define their\n            visibility scope: `pro.` (urlscan Pro users), `public.` (all registered\n            users), `private.` (only you), or `team.` (you and team members).\n            Defaults to None.\n        permissions (list[PermissionType] | None, optional): Determine whether only\n            other users on the same team or everyone on urlscan Pro can see the search.\n            Valid values: \"public:read\", \"team:read\", \"team:write\". Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Updated Saved Search object containing the search properties and unique _id.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/saved-searches/savedsearches-put\n\n    \"\"\"\n    search: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"datasource\": datasource,\n                \"query\": query,\n                \"name\": name,\n                \"description\": description,\n                \"longDescription\": long_description,\n                \"tlp\": tlp,\n                \"userTags\": user_tags,\n                \"permissions\": permissions,\n            },\n            kwargs,\n        )\n    )\n    data: dict[str, Any] = {\"search\": search}\n\n    res = self._put(f\"/api/v1/user/searches/{search_id}/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Subscription","title":"<code>urlscan.pro.Subscription</code>","text":"<p>               Bases: <code>BaseClient</code></p> <p>Subscription API client.</p> Source code in <code>src/urlscan/pro/subscription.py</code> <pre><code>class Subscription(BaseClient):\n    \"\"\"Subscription API client.\"\"\"\n\n    def get_subscriptions(self) -&gt; dict:\n        \"\"\"Get a list of Subscriptions for the current user.\n\n        Returns:\n            dict: List of subscriptions.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptions\n\n        \"\"\"\n        return self.get_json(\"/api/v1/user/subscriptions/\")\n\n    def create(\n        self,\n        *,\n        search_ids: list[str],\n        frequency: FrequencyType,\n        email_addresses: list[str],\n        name: str,\n        is_active: bool,\n        ignore_time: bool,\n        description: str | None = None,\n        week_days: list[WeekDaysType] | None = None,\n        permissions: list[SubscriptionPermissionType] | None = None,\n        channel_ids: list[str] | None = None,\n        incident_channel_ids: list[str] | None = None,\n        incident_profile_id: str | None = None,\n        incident_visibility: IncidentVisibilityType | None = None,\n        incident_creation_mode: IncidentCreationModeType | None = None,\n        incident_watch_keys: IncidentWatchKeyType | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Create a new subscription.\n\n        Args:\n            search_ids (list[str]): Array of search IDs associated with this subscription.\n            frequency (FrequencyType): Frequency of notifications (\"live\", \"hourly\", or \"daily\").\n            email_addresses (list[str]): Email addresses receiving the notifications.\n            name (str): Name of the subscription.\n            is_active (bool): Whether the subscription is active.\n            ignore_time (bool): Whether to ignore time constraints.\n            description (str | None, optional): Description of the subscription. Defaults to None.\n            week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n            permissions (list[SubscriptionPermissionType] | None, optional): Permissions associated with this subscription (team:read, team:write). Defaults to None.\n            channel_ids (list[str] | None, optional): Array of channel IDs associated with this subscription. Defaults to None.\n            incident_channel_ids (list[str] | None, optional): Array of incident channel IDs associated with this subscription. Defaults to None.\n            incident_profile_id (str | None, optional): Incident Profile ID associated with this subscription. Defaults to None.\n            incident_visibility (IncidentVisibilityType | None, optional): Incident visibility for this subscription (\"unlisted\" or \"private\"). Defaults to None.\n            incident_creation_mode (IncidentCreationModeType | None, optional): Incident creation rule for this subscription (\"none\", \"default\", \"always\", or \"ignore-if-exists\"). Defaults to None.\n            incident_watch_keys (IncidentWatchKeyType | None, optional): Source/key to watch in the incident (scans/page.url, scans/page.domain, scans/page.ip, scans/page.apexDomain, hostnames/hostname, hostnames/ip, hostnames/domain). Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Response containing the created subscription with an '_id' field.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionscreate\n\n        \"\"\"\n        subscription: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"searchIds\": search_ids,\n                    \"frequency\": frequency,\n                    \"emailAddresses\": email_addresses,\n                    \"name\": name,\n                    \"description\": description,\n                    \"isActive\": is_active,\n                    \"ignoreTime\": ignore_time,\n                    \"weekDays\": week_days,\n                    \"permissions\": permissions,\n                    \"channelIds\": channel_ids,\n                    \"incidentChannelIds\": incident_channel_ids,\n                    \"incidentProfileId\": incident_profile_id,\n                    \"incidentVisibility\": incident_visibility,\n                    \"incidentCreationMode\": incident_creation_mode,\n                    \"incidentWatchKeys\": incident_watch_keys,\n                },\n                kwargs,\n            )\n        )\n        data = {\"subscription\": subscription}\n\n        res = self._post(\"/api/v1/user/subscriptions/\", json=data)\n        return self._response_to_json(res)\n\n    def update(\n        self,\n        *,\n        subscription_id: str,\n        search_ids: list[str],\n        frequency: FrequencyType,\n        email_addresses: list[str],\n        name: str,\n        is_active: bool,\n        ignore_time: bool,\n        description: str | None = None,\n        week_days: list[WeekDaysType] | None = None,\n        permissions: list[SubscriptionPermissionType] | None = None,\n        channel_ids: list[str] | None = None,\n        incident_channel_ids: list[str] | None = None,\n        incident_profile_id: str | None = None,\n        incident_visibility: IncidentVisibilityType | None = None,\n        incident_creation_mode: IncidentCreationModeType | None = None,\n        incident_watch_keys: IncidentWatchKeyType | None = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"Update the settings for a subscription.\n\n        Args:\n            subscription_id (str): Subscription ID.\n            search_ids (list[str]): Array of search IDs associated with this subscription.\n            frequency (FrequencyType): Frequency of notifications (\"live\", \"hourly\", or \"daily\").\n            email_addresses (list[str]): Email addresses receiving the notifications.\n            name (str): Name of the subscription.\n            is_active (bool): Whether the subscription is active.\n            ignore_time (bool): Whether to ignore time constraints.\n            description (str | None, optional): Description of the subscription. Defaults to None.\n            week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n            permissions (list[SubscriptionPermissionType] | None, optional): Permissions associated with this subscription (team:read, team:write). Defaults to None.\n            channel_ids (list[str] | None, optional): Array of channel IDs associated with this subscription. Defaults to None.\n            incident_channel_ids (list[str] | None, optional): Array of incident channel IDs associated with this subscription. Defaults to None.\n            incident_profile_id (str | None, optional): Incident Profile ID associated with this subscription. Defaults to None.\n            incident_visibility (IncidentVisibilityType | None, optional): Incident visibility for this subscription (\"unlisted\" or \"private\"). Defaults to None.\n            incident_creation_mode (IncidentCreationModeType | None, optional): Incident creation rule for this subscription (\"none\", \"default\", \"always\", or \"ignore-if-exists\"). Defaults to None.\n            incident_watch_keys (IncidentWatchKeyType | None, optional): Source/key to watch in the incident (scans/page.url, scans/page.domain, scans/page.ip, scans/page.apexDomain, hostnames/hostname, hostnames/ip, hostnames/domain). Defaults to None.\n            **kwargs: Additional parameters to include in the request payload.\n\n        Returns:\n            dict: Response containing the updated subscription with an '_id' field.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsget\n\n        \"\"\"\n        subscription: dict[str, Any] = _compact(\n            _merge(\n                {\n                    \"searchIds\": search_ids,\n                    \"frequency\": frequency,\n                    \"emailAddresses\": email_addresses,\n                    \"name\": name,\n                    \"description\": description,\n                    \"isActive\": is_active,\n                    \"ignoreTime\": ignore_time,\n                    \"weekDays\": week_days,\n                    \"permissions\": permissions,\n                    \"channelIds\": channel_ids,\n                    \"incidentChannelIds\": incident_channel_ids,\n                    \"incidentProfileId\": incident_profile_id,\n                    \"incidentVisibility\": incident_visibility,\n                    \"incidentCreationMode\": incident_creation_mode,\n                    \"incidentWatchKeys\": incident_watch_keys,\n                },\n                kwargs,\n            )\n        )\n        data = {\"subscription\": subscription}\n\n        res = self._put(f\"/api/v1/user/subscriptions/{subscription_id}/\", json=data)\n        return self._response_to_json(res)\n\n    def delete_subscription(self, *, subscription_id: str) -&gt; dict:\n        \"\"\"Delete a subscription.\n\n        Args:\n            subscription_id (str): Subscription ID.\n\n        Returns:\n            dict: Empty response object confirming deletion.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsdelete\n\n        \"\"\"\n        res = self._delete(f\"/api/v1/user/subscriptions/{subscription_id}/\")\n        return self._response_to_json(res)\n\n    def get_results(self, *, subscription_id: str, datasource: str) -&gt; dict:\n        \"\"\"Get the search results for a specific subscription and datasource.\n\n        Args:\n            subscription_id (str): Subscription ID.\n            datasource (str): Datasource (e.g., \"scans\").\n\n        Returns:\n            dict: Search results.\n\n        Reference:\n            https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsresults\n\n        \"\"\"\n        return self.get_json(\n            f\"/api/v1/user/subscriptions/{subscription_id}/results/{datasource}/\"\n        )\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Subscription.create","title":"<code>create(*, search_ids, frequency, email_addresses, name, is_active, ignore_time, description=None, week_days=None, permissions=None, channel_ids=None, incident_channel_ids=None, incident_profile_id=None, incident_visibility=None, incident_creation_mode=None, incident_watch_keys=None, **kwargs)</code>","text":"<p>Create a new subscription.</p> <p>Parameters:</p> Name Type Description Default <code>search_ids</code> <code>list[str]</code> <p>Array of search IDs associated with this subscription.</p> required <code>frequency</code> <code>FrequencyType</code> <p>Frequency of notifications (\"live\", \"hourly\", or \"daily\").</p> required <code>email_addresses</code> <code>list[str]</code> <p>Email addresses receiving the notifications.</p> required <code>name</code> <code>str</code> <p>Name of the subscription.</p> required <code>is_active</code> <code>bool</code> <p>Whether the subscription is active.</p> required <code>ignore_time</code> <code>bool</code> <p>Whether to ignore time constraints.</p> required <code>description</code> <code>str | None</code> <p>Description of the subscription. Defaults to None.</p> <code>None</code> <code>week_days</code> <code>list[WeekDaysType] | None</code> <p>Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.</p> <code>None</code> <code>permissions</code> <code>list[SubscriptionPermissionType] | None</code> <p>Permissions associated with this subscription (team:read, team:write). Defaults to None.</p> <code>None</code> <code>channel_ids</code> <code>list[str] | None</code> <p>Array of channel IDs associated with this subscription. Defaults to None.</p> <code>None</code> <code>incident_channel_ids</code> <code>list[str] | None</code> <p>Array of incident channel IDs associated with this subscription. Defaults to None.</p> <code>None</code> <code>incident_profile_id</code> <code>str | None</code> <p>Incident Profile ID associated with this subscription. Defaults to None.</p> <code>None</code> <code>incident_visibility</code> <code>IncidentVisibilityType | None</code> <p>Incident visibility for this subscription (\"unlisted\" or \"private\"). Defaults to None.</p> <code>None</code> <code>incident_creation_mode</code> <code>IncidentCreationModeType | None</code> <p>Incident creation rule for this subscription (\"none\", \"default\", \"always\", or \"ignore-if-exists\"). Defaults to None.</p> <code>None</code> <code>incident_watch_keys</code> <code>IncidentWatchKeyType | None</code> <p>Source/key to watch in the incident (scans/page.url, scans/page.domain, scans/page.ip, scans/page.apexDomain, hostnames/hostname, hostnames/ip, hostnames/domain). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing the created subscription with an '_id' field.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionscreate</p> Source code in <code>src/urlscan/pro/subscription.py</code> <pre><code>def create(\n    self,\n    *,\n    search_ids: list[str],\n    frequency: FrequencyType,\n    email_addresses: list[str],\n    name: str,\n    is_active: bool,\n    ignore_time: bool,\n    description: str | None = None,\n    week_days: list[WeekDaysType] | None = None,\n    permissions: list[SubscriptionPermissionType] | None = None,\n    channel_ids: list[str] | None = None,\n    incident_channel_ids: list[str] | None = None,\n    incident_profile_id: str | None = None,\n    incident_visibility: IncidentVisibilityType | None = None,\n    incident_creation_mode: IncidentCreationModeType | None = None,\n    incident_watch_keys: IncidentWatchKeyType | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Create a new subscription.\n\n    Args:\n        search_ids (list[str]): Array of search IDs associated with this subscription.\n        frequency (FrequencyType): Frequency of notifications (\"live\", \"hourly\", or \"daily\").\n        email_addresses (list[str]): Email addresses receiving the notifications.\n        name (str): Name of the subscription.\n        is_active (bool): Whether the subscription is active.\n        ignore_time (bool): Whether to ignore time constraints.\n        description (str | None, optional): Description of the subscription. Defaults to None.\n        week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n        permissions (list[SubscriptionPermissionType] | None, optional): Permissions associated with this subscription (team:read, team:write). Defaults to None.\n        channel_ids (list[str] | None, optional): Array of channel IDs associated with this subscription. Defaults to None.\n        incident_channel_ids (list[str] | None, optional): Array of incident channel IDs associated with this subscription. Defaults to None.\n        incident_profile_id (str | None, optional): Incident Profile ID associated with this subscription. Defaults to None.\n        incident_visibility (IncidentVisibilityType | None, optional): Incident visibility for this subscription (\"unlisted\" or \"private\"). Defaults to None.\n        incident_creation_mode (IncidentCreationModeType | None, optional): Incident creation rule for this subscription (\"none\", \"default\", \"always\", or \"ignore-if-exists\"). Defaults to None.\n        incident_watch_keys (IncidentWatchKeyType | None, optional): Source/key to watch in the incident (scans/page.url, scans/page.domain, scans/page.ip, scans/page.apexDomain, hostnames/hostname, hostnames/ip, hostnames/domain). Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Response containing the created subscription with an '_id' field.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionscreate\n\n    \"\"\"\n    subscription: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"searchIds\": search_ids,\n                \"frequency\": frequency,\n                \"emailAddresses\": email_addresses,\n                \"name\": name,\n                \"description\": description,\n                \"isActive\": is_active,\n                \"ignoreTime\": ignore_time,\n                \"weekDays\": week_days,\n                \"permissions\": permissions,\n                \"channelIds\": channel_ids,\n                \"incidentChannelIds\": incident_channel_ids,\n                \"incidentProfileId\": incident_profile_id,\n                \"incidentVisibility\": incident_visibility,\n                \"incidentCreationMode\": incident_creation_mode,\n                \"incidentWatchKeys\": incident_watch_keys,\n            },\n            kwargs,\n        )\n    )\n    data = {\"subscription\": subscription}\n\n    res = self._post(\"/api/v1/user/subscriptions/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Subscription.delete_subscription","title":"<code>delete_subscription(*, subscription_id)</code>","text":"<p>Delete a subscription.</p> <p>Parameters:</p> Name Type Description Default <code>subscription_id</code> <code>str</code> <p>Subscription ID.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Empty response object confirming deletion.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsdelete</p> Source code in <code>src/urlscan/pro/subscription.py</code> <pre><code>def delete_subscription(self, *, subscription_id: str) -&gt; dict:\n    \"\"\"Delete a subscription.\n\n    Args:\n        subscription_id (str): Subscription ID.\n\n    Returns:\n        dict: Empty response object confirming deletion.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsdelete\n\n    \"\"\"\n    res = self._delete(f\"/api/v1/user/subscriptions/{subscription_id}/\")\n    return self._response_to_json(res)\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Subscription.get_results","title":"<code>get_results(*, subscription_id, datasource)</code>","text":"<p>Get the search results for a specific subscription and datasource.</p> <p>Parameters:</p> Name Type Description Default <code>subscription_id</code> <code>str</code> <p>Subscription ID.</p> required <code>datasource</code> <code>str</code> <p>Datasource (e.g., \"scans\").</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Search results.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsresults</p> Source code in <code>src/urlscan/pro/subscription.py</code> <pre><code>def get_results(self, *, subscription_id: str, datasource: str) -&gt; dict:\n    \"\"\"Get the search results for a specific subscription and datasource.\n\n    Args:\n        subscription_id (str): Subscription ID.\n        datasource (str): Datasource (e.g., \"scans\").\n\n    Returns:\n        dict: Search results.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsresults\n\n    \"\"\"\n    return self.get_json(\n        f\"/api/v1/user/subscriptions/{subscription_id}/results/{datasource}/\"\n    )\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Subscription.get_subscriptions","title":"<code>get_subscriptions()</code>","text":"<p>Get a list of Subscriptions for the current user.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>List of subscriptions.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptions</p> Source code in <code>src/urlscan/pro/subscription.py</code> <pre><code>def get_subscriptions(self) -&gt; dict:\n    \"\"\"Get a list of Subscriptions for the current user.\n\n    Returns:\n        dict: List of subscriptions.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptions\n\n    \"\"\"\n    return self.get_json(\"/api/v1/user/subscriptions/\")\n</code></pre>"},{"location":"references/pro/#urlscan.pro.Subscription.update","title":"<code>update(*, subscription_id, search_ids, frequency, email_addresses, name, is_active, ignore_time, description=None, week_days=None, permissions=None, channel_ids=None, incident_channel_ids=None, incident_profile_id=None, incident_visibility=None, incident_creation_mode=None, incident_watch_keys=None, **kwargs)</code>","text":"<p>Update the settings for a subscription.</p> <p>Parameters:</p> Name Type Description Default <code>subscription_id</code> <code>str</code> <p>Subscription ID.</p> required <code>search_ids</code> <code>list[str]</code> <p>Array of search IDs associated with this subscription.</p> required <code>frequency</code> <code>FrequencyType</code> <p>Frequency of notifications (\"live\", \"hourly\", or \"daily\").</p> required <code>email_addresses</code> <code>list[str]</code> <p>Email addresses receiving the notifications.</p> required <code>name</code> <code>str</code> <p>Name of the subscription.</p> required <code>is_active</code> <code>bool</code> <p>Whether the subscription is active.</p> required <code>ignore_time</code> <code>bool</code> <p>Whether to ignore time constraints.</p> required <code>description</code> <code>str | None</code> <p>Description of the subscription. Defaults to None.</p> <code>None</code> <code>week_days</code> <code>list[WeekDaysType] | None</code> <p>Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.</p> <code>None</code> <code>permissions</code> <code>list[SubscriptionPermissionType] | None</code> <p>Permissions associated with this subscription (team:read, team:write). Defaults to None.</p> <code>None</code> <code>channel_ids</code> <code>list[str] | None</code> <p>Array of channel IDs associated with this subscription. Defaults to None.</p> <code>None</code> <code>incident_channel_ids</code> <code>list[str] | None</code> <p>Array of incident channel IDs associated with this subscription. Defaults to None.</p> <code>None</code> <code>incident_profile_id</code> <code>str | None</code> <p>Incident Profile ID associated with this subscription. Defaults to None.</p> <code>None</code> <code>incident_visibility</code> <code>IncidentVisibilityType | None</code> <p>Incident visibility for this subscription (\"unlisted\" or \"private\"). Defaults to None.</p> <code>None</code> <code>incident_creation_mode</code> <code>IncidentCreationModeType | None</code> <p>Incident creation rule for this subscription (\"none\", \"default\", \"always\", or \"ignore-if-exists\"). Defaults to None.</p> <code>None</code> <code>incident_watch_keys</code> <code>IncidentWatchKeyType | None</code> <p>Source/key to watch in the incident (scans/page.url, scans/page.domain, scans/page.ip, scans/page.apexDomain, hostnames/hostname, hostnames/ip, hostnames/domain). Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to include in the request payload.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Response containing the updated subscription with an '_id' field.</p> Reference <p>https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsget</p> Source code in <code>src/urlscan/pro/subscription.py</code> <pre><code>def update(\n    self,\n    *,\n    subscription_id: str,\n    search_ids: list[str],\n    frequency: FrequencyType,\n    email_addresses: list[str],\n    name: str,\n    is_active: bool,\n    ignore_time: bool,\n    description: str | None = None,\n    week_days: list[WeekDaysType] | None = None,\n    permissions: list[SubscriptionPermissionType] | None = None,\n    channel_ids: list[str] | None = None,\n    incident_channel_ids: list[str] | None = None,\n    incident_profile_id: str | None = None,\n    incident_visibility: IncidentVisibilityType | None = None,\n    incident_creation_mode: IncidentCreationModeType | None = None,\n    incident_watch_keys: IncidentWatchKeyType | None = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"Update the settings for a subscription.\n\n    Args:\n        subscription_id (str): Subscription ID.\n        search_ids (list[str]): Array of search IDs associated with this subscription.\n        frequency (FrequencyType): Frequency of notifications (\"live\", \"hourly\", or \"daily\").\n        email_addresses (list[str]): Email addresses receiving the notifications.\n        name (str): Name of the subscription.\n        is_active (bool): Whether the subscription is active.\n        ignore_time (bool): Whether to ignore time constraints.\n        description (str | None, optional): Description of the subscription. Defaults to None.\n        week_days (list[WeekDaysType] | None, optional): Days of the week alerts will be generated (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). Defaults to None.\n        permissions (list[SubscriptionPermissionType] | None, optional): Permissions associated with this subscription (team:read, team:write). Defaults to None.\n        channel_ids (list[str] | None, optional): Array of channel IDs associated with this subscription. Defaults to None.\n        incident_channel_ids (list[str] | None, optional): Array of incident channel IDs associated with this subscription. Defaults to None.\n        incident_profile_id (str | None, optional): Incident Profile ID associated with this subscription. Defaults to None.\n        incident_visibility (IncidentVisibilityType | None, optional): Incident visibility for this subscription (\"unlisted\" or \"private\"). Defaults to None.\n        incident_creation_mode (IncidentCreationModeType | None, optional): Incident creation rule for this subscription (\"none\", \"default\", \"always\", or \"ignore-if-exists\"). Defaults to None.\n        incident_watch_keys (IncidentWatchKeyType | None, optional): Source/key to watch in the incident (scans/page.url, scans/page.domain, scans/page.ip, scans/page.apexDomain, hostnames/hostname, hostnames/ip, hostnames/domain). Defaults to None.\n        **kwargs: Additional parameters to include in the request payload.\n\n    Returns:\n        dict: Response containing the updated subscription with an '_id' field.\n\n    Reference:\n        https://docs.urlscan.io/apis/urlscan-openapi/subscriptions/subscriptionsget\n\n    \"\"\"\n    subscription: dict[str, Any] = _compact(\n        _merge(\n            {\n                \"searchIds\": search_ids,\n                \"frequency\": frequency,\n                \"emailAddresses\": email_addresses,\n                \"name\": name,\n                \"description\": description,\n                \"isActive\": is_active,\n                \"ignoreTime\": ignore_time,\n                \"weekDays\": week_days,\n                \"permissions\": permissions,\n                \"channelIds\": channel_ids,\n                \"incidentChannelIds\": incident_channel_ids,\n                \"incidentProfileId\": incident_profile_id,\n                \"incidentVisibility\": incident_visibility,\n                \"incidentCreationMode\": incident_creation_mode,\n                \"incidentWatchKeys\": incident_watch_keys,\n            },\n            kwargs,\n        )\n    )\n    data = {\"subscription\": subscription}\n\n    res = self._put(f\"/api/v1/user/subscriptions/{subscription_id}/\", json=data)\n    return self._response_to_json(res)\n</code></pre>"}]}