{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"urlscan-python","text":"<p>The official Python API client for urlscan.io.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install urlscan-python\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Start by importing <code>urlscan</code> module</p> <pre><code>&gt;&gt;&gt; import urlscan\n</code></pre> <p>Create a client with your API key:</p> <pre><code>&gt;&gt;&gt; client = urlscan.Client(\"&lt;your_api_key&gt;\")\n</code></pre> <p>Scan a URL:</p> <pre><code>&gt;&gt;&gt; res = client.scan(\"&lt;url&gt;\", visibility=\"public\")\n&gt;&gt;&gt; uuid: str = res[\"uuid\"]\n</code></pre> <p>Wait for a scan result:</p> <pre><code>&gt;&gt;&gt; client.wait_for_result(uuid)\n</code></pre> <p>Get a scan result:</p> <pre><code>&gt;&gt;&gt; result = client.get_result(uuid)\n</code></pre> <p>Bulk scan:</p> <pre><code>&gt;&gt;&gt; client.bulk_scan([\"&lt;url&gt;\", \"&lt;url&gt;\"], visibility=\"public\")\n</code></pre> <p>Alternatively, you can use <code>_and_get_result(s)</code> suffixed methods to do scan, wait and get at once.</p> <pre><code>&gt;&gt;&gt; client.scan_and_get_result(\"&lt;url&gt;\", visibility=\"public\")\n&gt;&gt;&gt; client.bulk_scan_and_get_results([\"&lt;url&gt;\", \"&lt;url&gt;\"], visibility=\"public\")\n</code></pre> <p><code>urlscan.Client.search()</code> returns an iterator to iterate search results:</p> <pre><code>&gt;&gt;&gt; for result in client.search(\"page.domain:example.com\"):\n&gt;&gt;&gt;     print(result[\"_id\"])\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>See Examples.</p>"},{"location":"#references","title":"References","text":"<ul> <li>Client</li> <li>Iterator</li> <li>Errors</li> </ul>"},{"location":"#help-wanted","title":"Help Wanted?","text":"<p>Please feel free to to open an issue if you find a bug or some feature that you want to see implemented.</p>"},{"location":"dev/","title":"Development","text":"<p>This doc explains how to set up dev env if you want to get involved with this project.</p>"},{"location":"dev/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> </ul>"},{"location":"dev/#setup","title":"Setup","text":"<p>This project uses uv as a project manager and Lefthook as a Git hooks manager.</p> <pre><code>git clone https://github.com/urlscan/urlscan-python\ncd urlscan-python\n\n# install uv\npip install -r requirements.txt\n# sync uv\nuv sync\n# install Lefthook\nuv run lefthook install\n</code></pre>"},{"location":"dev/#test","title":"Test","text":"<p>This project uses pytest as a testing framework.</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"dev/#docs","title":"Docs","text":"<p>This project uses MkDocs as a documentation tool.</p> <pre><code># run the dev server\nuv run mkdocs serve\n# or build the docs\nuv run mkdocs build\n</code></pre>"},{"location":"references/client/","title":"Client","text":""},{"location":"references/client/#urlscan.Client","title":"<code>urlscan.Client</code>","text":"Source code in <code>src/urlscan/client.py</code> <pre><code>class Client:\n    def __init__(\n        self,\n        api_key: str,\n        base_url: str = BASE_URL,\n        user_agent: str = USER_AGENT,\n        trust_env: bool = False,\n        timeout: TimeoutTypes = 60,\n        proxy: str | None = None,\n        verify: bool = True,\n        retry: bool = False,\n    ):\n        \"\"\"\n        Args:\n            api_key (str): Your urlscan.io API key.\n            base_url (str, optional): Base URL. Defaults to BASE_URL.\n            user_agent (str, optional): User agent. Defaults to USER_AGENT.\n            trust_env (bool, optional): Enable or disable usage of environment variables for configuration. Defaults to False.\n            timeout (TimeoutTypes, optional): timeout configuration to use when sending request. Defaults to 60.\n            proxy (str | None, optional): Proxy URL where all the traffic should be routed. Defaults to None.\n            verify (bool, optional): Either `True` to use an SSL context with the default CA bundle, `False` to disable verification. Defaults to True.\n            retry (bool, optional): Whether to use automatic X-Rate-Limit-Reset-After HTTP header based retry. Defaults to False.\n        \"\"\"\n        self._api_key = api_key\n        self._base_url = base_url\n        self._user_agent = user_agent\n        self._trust_env = trust_env\n        self._timeout = timeout\n        self._proxy = proxy\n        self._verify = verify\n        self._retry = retry\n\n        self._session: httpx.Client | None = None\n        self._rate_limit_memo: RateLimitMemo = {\n            \"public\": None,\n            \"private\": None,\n            \"unlisted\": None,\n            \"retrieve\": None,\n            \"search\": None,\n        }\n\n        self._scan_uuid_timestamp_memo: dict[str, float] = {}\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, item_type: Any, value: Any, traceback: Any):\n        self.close()\n\n    def close(self):\n        if self._session:\n            self._session.close()\n            self._session = None\n\n    def _get_session(self) -&gt; httpx.Client:\n        if self._session:\n            return self._session\n\n        headers = _compact(\n            {\n                \"User-Agent\": self._user_agent,\n                \"API-Key\": self._api_key,\n            }\n        )\n        transport: httpx.HTTPTransport | None = None\n        if self._retry:\n            transport = RetryTransport()\n\n        self._session = httpx.Client(\n            base_url=self._base_url,\n            headers=headers,\n            timeout=self._timeout,\n            proxy=self._proxy,\n            verify=self._verify,\n            trust_env=self._trust_env,\n            transport=transport,\n        )\n        return self._session\n\n    def _get_action(self, request: httpx.Request) -&gt; ActionType | None:\n        path = request.url.path\n        if request.method == \"GET\":\n            if path == \"/api/v1/search/\":\n                return \"search\"\n\n            if path.startswith(\"/api/v1/result/\"):\n                return \"retrieve\"\n\n            return None\n\n        if request.method == \"POST\":\n            if path != \"/api/v1/scan/\":\n                return None\n\n            if request.headers.get(\"Content-Type\") != \"application/json\":\n                return None\n\n            with contextlib.suppress(json.JSONDecodeError):\n                data: dict = json.loads(request.content)\n                return data.get(\"visibility\")\n\n        return None\n\n    def _send_request(\n        self, session: httpx.Client, request: httpx.Request\n    ) -&gt; ClientResponse:\n        # let it automatic retry if retry is enabled\n        if self._retry:\n            return ClientResponse(session.send(request))\n\n        action = self._get_action(request)\n        if action:\n            rate_limit: RateLimit | None = self._rate_limit_memo.get(action)\n            if rate_limit:\n                utcnow = datetime.datetime.now(datetime.timezone.utc)\n                if rate_limit.remaining == 0 and rate_limit.reset &gt; utcnow:\n                    raise RateLimitRemainingError(\n                        f\"{action} is rate limited. Wait until {utcnow}.\"\n                    )\n\n        res = ClientResponse(session.send(request))\n\n        # use action in response headers\n        action = res.headers.get(\"X-Rate-Limit-Action\")\n        if action:\n            remaining = res.headers.get(\"X-Rate-Limit-Remaining\")\n            reset = res.headers.get(\"X-Rate-Limit-Reset\")\n            if remaining and reset:\n                self._rate_limit_memo[action] = RateLimit(\n                    remaining=int(remaining),\n                    reset=parse_datetime(reset),\n                )\n\n        return res\n\n    def get(self, path: str, params: QueryParamTypes | None = None) -&gt; ClientResponse:\n        \"\"\"Send a GET request to a given API endpoint.\n\n        Args:\n            path (str): Path to API endpoint.\n            params (QueryParamTypes | None, optional): Query parameters. Defaults to None.\n\n        Returns:\n            ClientResponse: Response.\n        \"\"\"\n        session = self._get_session()\n        req = session.build_request(\"GET\", path, params=params)\n        return self._send_request(session, req)\n\n    def get_json(self, path: str, params: QueryParamTypes | None = None) -&gt; dict:\n        res = self.get(path, params=params)\n        return self._response_to_json(res)\n\n    def post(\n        self,\n        path: str,\n        json: Any | None = None,\n        data: RequestData | None = None,\n    ) -&gt; ClientResponse:\n        \"\"\"Send a POST request to a given API endpoint.\n\n        Args:\n            path (str): Path.\n            json (Any | None, optional): Dict to send in request body as JSON. Defaults to None.\n            data (RequestData | None, optional): Dict to send in request body. Defaults to None.\n\n        Returns:\n            ClientResponse: Response.\n        \"\"\"\n        session = self._get_session()\n        req = session.build_request(\"POST\", path, json=json, data=data)\n        return self._send_request(session, req)\n\n    def download(\n        self,\n        path: str,\n        file: BinaryIO,\n        params: QueryParamTypes | None = None,\n    ) -&gt; None:\n        \"\"\"Download a file from a given API endpoint.\n\n        Args:\n            path (str): Path to API endpoint.\n            file (BinaryIO): File object to write to.\n            params (QueryParamTypes | None, optional): Query parameters. Defaults to None.\n\n        Returns:\n            BytesIO: File content.\n        \"\"\"\n        res = self.get(path, params=params)\n        file.write(res.content)\n        return\n\n    def get_content(self, path: str, params: QueryParamTypes | None = None) -&gt; bytes:\n        res = self.get(path, params=params)\n        return self._response_to_content(res)\n\n    def get_text(self, path: str, params: QueryParamTypes | None = None) -&gt; str:\n        res = self.get(path, params=params)\n        return self._response_to_str(res)\n\n    def get_result(self, uuid: str) -&gt; dict:\n        \"\"\"Get a result of a scan by UUID.\n\n        Args:\n            uuid (str): UUID.\n\n        Returns:\n            Dict: Scan result.\n\n        Reference:\n            https://urlscan.io/docs/api/#result\n        \"\"\"\n        return self.get_json(f\"/api/v1/result/{uuid}/\")\n\n    def get_screenshot(self, uuid: str) -&gt; BytesIO:\n        \"\"\"Get a screenshot of a scan by UUID.\n\n        Args:\n            uuid (str): UUID.\n\n        Returns:\n            : Screenshot (img/png) as bytes.\n\n        Reference:\n            https://urlscan.io/docs/api/#screenshot\n        \"\"\"\n        res = self.get(f\"/screenshots/{uuid}.png\")\n        bio = BytesIO(res.content)\n        bio.name = res.basename\n        return bio\n\n    def get_dom(self, uuid: str) -&gt; str:\n        \"\"\"Get a DOM of a scan by UUID.\n\n        Args:\n            uuid (str): UUID\n\n        Returns:\n            str: DOM as a string.\n\n        Reference:\n            https://urlscan.io/docs/api/#dom\n        \"\"\"\n        return self.get_text(f\"/dom/{uuid}/\")\n\n    def search(\n        self,\n        q: str = \"\",\n        size: int = 100,\n        limit: int | None = None,\n        search_after: str | None = None,\n    ) -&gt; SearchIterator:\n        \"\"\"Search.\n\n        Args:\n            q (str): Query term. Defaults to \"\".\n            size (int, optional): Number of results returned in a search. Defaults to 100.\n            limit (int | None, optional): . Defaults to None.\n            search_after (str | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n        Returns:\n            SearchIterator: Search iterator.\n\n        Reference:\n            https://urlscan.io/docs/api/#search\n        \"\"\"\n        return SearchIterator(\n            self,\n            q=q,\n            size=size,\n            limit=limit,\n            search_after=search_after,\n        )\n\n    def scan(\n        self,\n        url: str,\n        *,\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n    ) -&gt; dict:\n        \"\"\"Scan a given URL.\n\n        Args:\n            url (str): URL to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n        Returns:\n            dict: Scan response.\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n        \"\"\"\n        data = _compact(\n            {\n                \"url\": url,\n                \"tags\": tags,\n                \"visibility\": visibility,\n                \"customagent\": customagent,\n                \"referer\": referer,\n                \"overrideSafety\": override_safety,\n                \"country\": country,\n            }\n        )\n        res = self.post(\"/api/v1/scan/\", json=data)\n        json_res = self._response_to_json(res)\n\n        json_visibility = json_res.get(\"visibility\")\n        if json_visibility is not None and json_visibility != visibility:\n            logger.warning(f\"Visibility is enforced to {json_visibility}.\")\n\n        # memoize the scan UUID &amp; timestamp\n        uuid = json_res.get(\"uuid\")\n        if isinstance(uuid, str):\n            self._scan_uuid_timestamp_memo[uuid] = time.time()\n\n        return json_res\n\n    def bulk_scan(\n        self,\n        urls: list[str],\n        *,\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n    ) -&gt; list[tuple[str, dict | Exception]]:\n        \"\"\"Scan multiple URLs in bulk.\n\n        Args:\n            urls (list[str]): List of URLs to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n        Returns:\n            list[tuple[str, dict | Exception]]: A list of tuples of (url, scan response or error).\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n        \"\"\"\n\n        def inner(url: str) -&gt; dict | Exception:\n            try:\n                return self.scan(\n                    url,\n                    visibility=visibility,\n                    tags=tags,\n                    customagent=customagent,\n                    referer=referer,\n                    override_safety=override_safety,\n                    country=country,\n                )\n            except Exception as e:\n                return e\n\n        return [(url, inner(url)) for url in urls]\n\n    def wait_for_result(\n        self,\n        uuid: str,\n        timeout: float = 60.0,\n        interval: float = 1.0,\n        initial_wait: float | None = 10.0,\n    ) -&gt; None:\n        \"\"\"Wait for a scan result to be available.\n\n        Args:\n            uuid (str): UUID of a result.\n            timeout (float, optional): Timeout in seconds. Defaults to 60.0.\n            interval (float, optional): Interval in seconds. Defaults to 1.0.\n            initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n        \"\"\"\n        session = self._get_session()\n        req = session.build_request(\"HEAD\", f\"/api/v1/result/{uuid}/\")\n\n        scanned_at = self._scan_uuid_timestamp_memo.get(uuid)\n        if scanned_at and initial_wait:\n            elapsed = time.time() - scanned_at\n            if elapsed &lt; initial_wait:\n                time.sleep(initial_wait - elapsed)\n\n        start_time = time.time()\n        while True:\n            res = self._send_request(session, req)\n            if res.status_code == 200:\n                self._scan_uuid_timestamp_memo.pop(uuid, None)\n                return\n\n            if time.time() - start_time &gt; timeout:\n                raise TimeoutError(\"Timeout waiting for scan result.\")\n\n            time.sleep(interval)\n\n    def scan_and_get_result(\n        self,\n        url: str,\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n        timeout: float = 60.0,\n        interval: float = 1.0,\n        initial_wait: float | None = 10.0,\n    ):\n        \"\"\"Scan a given URL, wait for a result and get it.\n\n        Args:\n            url (str): URL to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n            timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n            interval (float, optional): Interval in seconds. Defaults to 1.0.\n            initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n        Returns:\n            dict: Scan result.\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n        \"\"\"\n        res = self.scan(\n            url,\n            visibility=visibility,\n            tags=tags,\n            customagent=customagent,\n            referer=referer,\n            override_safety=override_safety,\n            country=country,\n        )\n        uuid: str = res[\"uuid\"]\n        self.wait_for_result(\n            uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n        )\n        return self.get_result(uuid)\n\n    def bulk_scan_and_get_results(\n        self,\n        urls: list[str],\n        visibility: VisibilityType,\n        tags: list[str] | None = None,\n        customagent: str | None = None,\n        referer: str | None = None,\n        override_safety: Any = None,\n        country: str | None = None,\n        timeout: float = 60.0,\n        interval: float = 1.0,\n        initial_wait: float | None = 10.0,\n    ) -&gt; list[tuple[str, dict | Exception]]:\n        \"\"\"Scan URLs, wait for results and get them.\n\n        Args:\n            urls (list[str]): URLs to scan.\n            visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n            tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n            customagent (str | None, optional): Custom user agent. Defaults to None.\n            referer (str | None, optional): Referer. Defaults to None.\n            override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n            country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n            timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n            interval (float, optional): Interval in seconds. Defaults to 1.0.\n            initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n        Returns:\n            list[tuple[str, dict | Exception]]: A list of tuples of (url, result or error).\n\n        Reference:\n            https://urlscan.io/docs/api/#scan\n        \"\"\"\n\n        responses = self.bulk_scan(\n            urls,\n            visibility=visibility,\n            tags=tags,\n            customagent=customagent,\n            referer=referer,\n            override_safety=override_safety,\n            country=country,\n        )\n\n        def mapping(res_or_error: dict | Exception) -&gt; dict | Exception:\n            if isinstance(res_or_error, Exception):\n                return res_or_error\n\n            uuid: str = res_or_error[\"uuid\"]\n            self.wait_for_result(\n                uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n            )\n            return self.get_result(uuid)\n\n        return [(url, mapping(res_or_error)) for url, res_or_error in responses]\n\n    def _get_error(self, res: ClientResponse) -&gt; APIError | None:\n        try:\n            res.raise_for_status()\n        except httpx.HTTPStatusError as exc:\n            data: dict = exc.response.json()\n            message: str = data[\"message\"]\n            description: str | None = data.get(\"description\")\n            status: int = data[\"status\"]\n\n            # ref. https://urlscan.io/docs/api/#ratelimit\n            if status == 429:\n                rate_limit_reset_after = float(\n                    exc.response.headers.get(\"X-Rate-Limit-Reset-After\", 0)\n                )\n                return RateLimitError(\n                    message,\n                    description=description,\n                    status=status,\n                    rate_limit_reset_after=rate_limit_reset_after,\n                )\n\n            return APIError(message, description=description, status=status)\n\n        return None\n\n    def _response_to_json(self, res: ClientResponse) -&gt; dict:\n        error = self._get_error(res)\n        if error:\n            raise error\n\n        return res.json()\n\n    def _response_to_str(self, res: ClientResponse) -&gt; str:\n        error = self._get_error(res)\n        if error:\n            raise error\n\n        return res.text\n\n    def _response_to_content(self, res: ClientResponse) -&gt; bytes:\n        error = self._get_error(res)\n        if error:\n            raise error\n\n        return res.content\n</code></pre>"},{"location":"references/client/#urlscan.Client.__init__","title":"<code>__init__(api_key, base_url=BASE_URL, user_agent=USER_AGENT, trust_env=False, timeout=60, proxy=None, verify=True, retry=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>Your urlscan.io API key.</p> required <code>base_url</code> <code>str</code> <p>Base URL. Defaults to BASE_URL.</p> <code>BASE_URL</code> <code>user_agent</code> <code>str</code> <p>User agent. Defaults to USER_AGENT.</p> <code>USER_AGENT</code> <code>trust_env</code> <code>bool</code> <p>Enable or disable usage of environment variables for configuration. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>TimeoutTypes</code> <p>timeout configuration to use when sending request. Defaults to 60.</p> <code>60</code> <code>proxy</code> <code>str | None</code> <p>Proxy URL where all the traffic should be routed. Defaults to None.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Either <code>True</code> to use an SSL context with the default CA bundle, <code>False</code> to disable verification. Defaults to True.</p> <code>True</code> <code>retry</code> <code>bool</code> <p>Whether to use automatic X-Rate-Limit-Reset-After HTTP header based retry. Defaults to False.</p> <code>False</code> Source code in <code>src/urlscan/client.py</code> <pre><code>def __init__(\n    self,\n    api_key: str,\n    base_url: str = BASE_URL,\n    user_agent: str = USER_AGENT,\n    trust_env: bool = False,\n    timeout: TimeoutTypes = 60,\n    proxy: str | None = None,\n    verify: bool = True,\n    retry: bool = False,\n):\n    \"\"\"\n    Args:\n        api_key (str): Your urlscan.io API key.\n        base_url (str, optional): Base URL. Defaults to BASE_URL.\n        user_agent (str, optional): User agent. Defaults to USER_AGENT.\n        trust_env (bool, optional): Enable or disable usage of environment variables for configuration. Defaults to False.\n        timeout (TimeoutTypes, optional): timeout configuration to use when sending request. Defaults to 60.\n        proxy (str | None, optional): Proxy URL where all the traffic should be routed. Defaults to None.\n        verify (bool, optional): Either `True` to use an SSL context with the default CA bundle, `False` to disable verification. Defaults to True.\n        retry (bool, optional): Whether to use automatic X-Rate-Limit-Reset-After HTTP header based retry. Defaults to False.\n    \"\"\"\n    self._api_key = api_key\n    self._base_url = base_url\n    self._user_agent = user_agent\n    self._trust_env = trust_env\n    self._timeout = timeout\n    self._proxy = proxy\n    self._verify = verify\n    self._retry = retry\n\n    self._session: httpx.Client | None = None\n    self._rate_limit_memo: RateLimitMemo = {\n        \"public\": None,\n        \"private\": None,\n        \"unlisted\": None,\n        \"retrieve\": None,\n        \"search\": None,\n    }\n\n    self._scan_uuid_timestamp_memo: dict[str, float] = {}\n</code></pre>"},{"location":"references/client/#urlscan.Client.bulk_scan","title":"<code>bulk_scan(urls, *, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None)</code>","text":"<p>Scan multiple URLs in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list[str]</code> <p>List of URLs to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[str, dict | Exception]]</code> <p>list[tuple[str, dict | Exception]]: A list of tuples of (url, scan response or error).</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def bulk_scan(\n    self,\n    urls: list[str],\n    *,\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n) -&gt; list[tuple[str, dict | Exception]]:\n    \"\"\"Scan multiple URLs in bulk.\n\n    Args:\n        urls (list[str]): List of URLs to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n    Returns:\n        list[tuple[str, dict | Exception]]: A list of tuples of (url, scan response or error).\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n    \"\"\"\n\n    def inner(url: str) -&gt; dict | Exception:\n        try:\n            return self.scan(\n                url,\n                visibility=visibility,\n                tags=tags,\n                customagent=customagent,\n                referer=referer,\n                override_safety=override_safety,\n                country=country,\n            )\n        except Exception as e:\n            return e\n\n    return [(url, inner(url)) for url in urls]\n</code></pre>"},{"location":"references/client/#urlscan.Client.bulk_scan_and_get_results","title":"<code>bulk_scan_and_get_results(urls, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None, timeout=60.0, interval=1.0, initial_wait=10.0)</code>","text":"<p>Scan URLs, wait for results and get them.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list[str]</code> <p>URLs to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Timeout for waiting a result in seconds. Defaults to 60.0.</p> <code>60.0</code> <code>interval</code> <code>float</code> <p>Interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <code>initial_wait</code> <code>float | None</code> <p>Initial wait time in seconds. Set None to disable. Defaults to 10.0.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>list[tuple[str, dict | Exception]]</code> <p>list[tuple[str, dict | Exception]]: A list of tuples of (url, result or error).</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def bulk_scan_and_get_results(\n    self,\n    urls: list[str],\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n    timeout: float = 60.0,\n    interval: float = 1.0,\n    initial_wait: float | None = 10.0,\n) -&gt; list[tuple[str, dict | Exception]]:\n    \"\"\"Scan URLs, wait for results and get them.\n\n    Args:\n        urls (list[str]): URLs to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n        timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n        interval (float, optional): Interval in seconds. Defaults to 1.0.\n        initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n    Returns:\n        list[tuple[str, dict | Exception]]: A list of tuples of (url, result or error).\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n    \"\"\"\n\n    responses = self.bulk_scan(\n        urls,\n        visibility=visibility,\n        tags=tags,\n        customagent=customagent,\n        referer=referer,\n        override_safety=override_safety,\n        country=country,\n    )\n\n    def mapping(res_or_error: dict | Exception) -&gt; dict | Exception:\n        if isinstance(res_or_error, Exception):\n            return res_or_error\n\n        uuid: str = res_or_error[\"uuid\"]\n        self.wait_for_result(\n            uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n        )\n        return self.get_result(uuid)\n\n    return [(url, mapping(res_or_error)) for url, res_or_error in responses]\n</code></pre>"},{"location":"references/client/#urlscan.Client.download","title":"<code>download(path, file, params=None)</code>","text":"<p>Download a file from a given API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to API endpoint.</p> required <code>file</code> <code>BinaryIO</code> <p>File object to write to.</p> required <code>params</code> <code>QueryParamTypes | None</code> <p>Query parameters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BytesIO</code> <code>None</code> <p>File content.</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def download(\n    self,\n    path: str,\n    file: BinaryIO,\n    params: QueryParamTypes | None = None,\n) -&gt; None:\n    \"\"\"Download a file from a given API endpoint.\n\n    Args:\n        path (str): Path to API endpoint.\n        file (BinaryIO): File object to write to.\n        params (QueryParamTypes | None, optional): Query parameters. Defaults to None.\n\n    Returns:\n        BytesIO: File content.\n    \"\"\"\n    res = self.get(path, params=params)\n    file.write(res.content)\n    return\n</code></pre>"},{"location":"references/client/#urlscan.Client.get","title":"<code>get(path, params=None)</code>","text":"<p>Send a GET request to a given API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to API endpoint.</p> required <code>params</code> <code>QueryParamTypes | None</code> <p>Query parameters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ClientResponse</code> <code>ClientResponse</code> <p>Response.</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get(self, path: str, params: QueryParamTypes | None = None) -&gt; ClientResponse:\n    \"\"\"Send a GET request to a given API endpoint.\n\n    Args:\n        path (str): Path to API endpoint.\n        params (QueryParamTypes | None, optional): Query parameters. Defaults to None.\n\n    Returns:\n        ClientResponse: Response.\n    \"\"\"\n    session = self._get_session()\n    req = session.build_request(\"GET\", path, params=params)\n    return self._send_request(session, req)\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_dom","title":"<code>get_dom(uuid)</code>","text":"<p>Get a DOM of a scan by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOM as a string.</p> Reference <p>https://urlscan.io/docs/api/#dom</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_dom(self, uuid: str) -&gt; str:\n    \"\"\"Get a DOM of a scan by UUID.\n\n    Args:\n        uuid (str): UUID\n\n    Returns:\n        str: DOM as a string.\n\n    Reference:\n        https://urlscan.io/docs/api/#dom\n    \"\"\"\n    return self.get_text(f\"/dom/{uuid}/\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_result","title":"<code>get_result(uuid)</code>","text":"<p>Get a result of a scan by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>dict</code> <p>Scan result.</p> Reference <p>https://urlscan.io/docs/api/#result</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_result(self, uuid: str) -&gt; dict:\n    \"\"\"Get a result of a scan by UUID.\n\n    Args:\n        uuid (str): UUID.\n\n    Returns:\n        Dict: Scan result.\n\n    Reference:\n        https://urlscan.io/docs/api/#result\n    \"\"\"\n    return self.get_json(f\"/api/v1/result/{uuid}/\")\n</code></pre>"},{"location":"references/client/#urlscan.Client.get_screenshot","title":"<code>get_screenshot(uuid)</code>","text":"<p>Get a screenshot of a scan by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID.</p> required <p>Returns:</p> Type Description <code>BytesIO</code> <p>Screenshot (img/png) as bytes.</p> Reference <p>https://urlscan.io/docs/api/#screenshot</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def get_screenshot(self, uuid: str) -&gt; BytesIO:\n    \"\"\"Get a screenshot of a scan by UUID.\n\n    Args:\n        uuid (str): UUID.\n\n    Returns:\n        : Screenshot (img/png) as bytes.\n\n    Reference:\n        https://urlscan.io/docs/api/#screenshot\n    \"\"\"\n    res = self.get(f\"/screenshots/{uuid}.png\")\n    bio = BytesIO(res.content)\n    bio.name = res.basename\n    return bio\n</code></pre>"},{"location":"references/client/#urlscan.Client.post","title":"<code>post(path, json=None, data=None)</code>","text":"<p>Send a POST request to a given API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path.</p> required <code>json</code> <code>Any | None</code> <p>Dict to send in request body as JSON. Defaults to None.</p> <code>None</code> <code>data</code> <code>RequestData | None</code> <p>Dict to send in request body. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ClientResponse</code> <code>ClientResponse</code> <p>Response.</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def post(\n    self,\n    path: str,\n    json: Any | None = None,\n    data: RequestData | None = None,\n) -&gt; ClientResponse:\n    \"\"\"Send a POST request to a given API endpoint.\n\n    Args:\n        path (str): Path.\n        json (Any | None, optional): Dict to send in request body as JSON. Defaults to None.\n        data (RequestData | None, optional): Dict to send in request body. Defaults to None.\n\n    Returns:\n        ClientResponse: Response.\n    \"\"\"\n    session = self._get_session()\n    req = session.build_request(\"POST\", path, json=json, data=data)\n    return self._send_request(session, req)\n</code></pre>"},{"location":"references/client/#urlscan.Client.scan","title":"<code>scan(url, *, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None)</code>","text":"<p>Scan a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Scan response.</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def scan(\n    self,\n    url: str,\n    *,\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n) -&gt; dict:\n    \"\"\"Scan a given URL.\n\n    Args:\n        url (str): URL to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n\n    Returns:\n        dict: Scan response.\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n    \"\"\"\n    data = _compact(\n        {\n            \"url\": url,\n            \"tags\": tags,\n            \"visibility\": visibility,\n            \"customagent\": customagent,\n            \"referer\": referer,\n            \"overrideSafety\": override_safety,\n            \"country\": country,\n        }\n    )\n    res = self.post(\"/api/v1/scan/\", json=data)\n    json_res = self._response_to_json(res)\n\n    json_visibility = json_res.get(\"visibility\")\n    if json_visibility is not None and json_visibility != visibility:\n        logger.warning(f\"Visibility is enforced to {json_visibility}.\")\n\n    # memoize the scan UUID &amp; timestamp\n    uuid = json_res.get(\"uuid\")\n    if isinstance(uuid, str):\n        self._scan_uuid_timestamp_memo[uuid] = time.time()\n\n    return json_res\n</code></pre>"},{"location":"references/client/#urlscan.Client.scan_and_get_result","title":"<code>scan_and_get_result(url, visibility, tags=None, customagent=None, referer=None, override_safety=None, country=None, timeout=60.0, interval=1.0, initial_wait=10.0)</code>","text":"<p>Scan a given URL, wait for a result and get it.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to scan.</p> required <code>visibility</code> <code>VisibilityType</code> <p>Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".</p> required <code>tags</code> <code>list[str] | None</code> <p>Tags to be attached. Defaults to None.</p> <code>None</code> <code>customagent</code> <code>str | None</code> <p>Custom user agent. Defaults to None.</p> <code>None</code> <code>referer</code> <code>str | None</code> <p>Referer. Defaults to None.</p> <code>None</code> <code>override_safety</code> <code>Any</code> <p>If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Timeout for waiting a result in seconds. Defaults to 60.0.</p> <code>60.0</code> <code>interval</code> <code>float</code> <p>Interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <code>initial_wait</code> <code>float | None</code> <p>Initial wait time in seconds. Set None to disable. Defaults to 10.0.</p> <code>10.0</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Scan result.</p> Reference <p>https://urlscan.io/docs/api/#scan</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def scan_and_get_result(\n    self,\n    url: str,\n    visibility: VisibilityType,\n    tags: list[str] | None = None,\n    customagent: str | None = None,\n    referer: str | None = None,\n    override_safety: Any = None,\n    country: str | None = None,\n    timeout: float = 60.0,\n    interval: float = 1.0,\n    initial_wait: float | None = 10.0,\n):\n    \"\"\"Scan a given URL, wait for a result and get it.\n\n    Args:\n        url (str): URL to scan.\n        visibility (VisibilityType): Visibility of the scan. Can be \"public\", \"private\", or \"unlisted\".\n        tags (list[str] | None, optional): Tags to be attached. Defaults to None.\n        customagent (str | None, optional): Custom user agent. Defaults to None.\n        referer (str | None, optional): Referer. Defaults to None.\n        override_safety (Any, optional): If set to any value, this will disable reclassification of URLs with potential PII in them. Defaults to None.\n        country (str | None, optional): Specify which country the scan should be performed from (2-Letter ISO-3166-1 alpha-2 country. Defaults to None.\n        timeout (float, optional): Timeout for waiting a result in seconds. Defaults to 60.0.\n        interval (float, optional): Interval in seconds. Defaults to 1.0.\n        initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n\n    Returns:\n        dict: Scan result.\n\n    Reference:\n        https://urlscan.io/docs/api/#scan\n    \"\"\"\n    res = self.scan(\n        url,\n        visibility=visibility,\n        tags=tags,\n        customagent=customagent,\n        referer=referer,\n        override_safety=override_safety,\n        country=country,\n    )\n    uuid: str = res[\"uuid\"]\n    self.wait_for_result(\n        uuid, timeout=timeout, interval=interval, initial_wait=initial_wait\n    )\n    return self.get_result(uuid)\n</code></pre>"},{"location":"references/client/#urlscan.Client.search","title":"<code>search(q='', size=100, limit=None, search_after=None)</code>","text":"<p>Search.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str</code> <p>Query term. Defaults to \"\".</p> <code>''</code> <code>size</code> <code>int</code> <p>Number of results returned in a search. Defaults to 100.</p> <code>100</code> <code>limit</code> <code>int | None</code> <p>. Defaults to None.</p> <code>None</code> <code>search_after</code> <code>str | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SearchIterator</code> <code>SearchIterator</code> <p>Search iterator.</p> Reference <p>https://urlscan.io/docs/api/#search</p> Source code in <code>src/urlscan/client.py</code> <pre><code>def search(\n    self,\n    q: str = \"\",\n    size: int = 100,\n    limit: int | None = None,\n    search_after: str | None = None,\n) -&gt; SearchIterator:\n    \"\"\"Search.\n\n    Args:\n        q (str): Query term. Defaults to \"\".\n        size (int, optional): Number of results returned in a search. Defaults to 100.\n        limit (int | None, optional): . Defaults to None.\n        search_after (str | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n\n    Returns:\n        SearchIterator: Search iterator.\n\n    Reference:\n        https://urlscan.io/docs/api/#search\n    \"\"\"\n    return SearchIterator(\n        self,\n        q=q,\n        size=size,\n        limit=limit,\n        search_after=search_after,\n    )\n</code></pre>"},{"location":"references/client/#urlscan.Client.wait_for_result","title":"<code>wait_for_result(uuid, timeout=60.0, interval=1.0, initial_wait=10.0)</code>","text":"<p>Wait for a scan result to be available.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>UUID of a result.</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds. Defaults to 60.0.</p> <code>60.0</code> <code>interval</code> <code>float</code> <p>Interval in seconds. Defaults to 1.0.</p> <code>1.0</code> <code>initial_wait</code> <code>float | None</code> <p>Initial wait time in seconds. Set None to disable. Defaults to 10.0.</p> <code>10.0</code> Source code in <code>src/urlscan/client.py</code> <pre><code>def wait_for_result(\n    self,\n    uuid: str,\n    timeout: float = 60.0,\n    interval: float = 1.0,\n    initial_wait: float | None = 10.0,\n) -&gt; None:\n    \"\"\"Wait for a scan result to be available.\n\n    Args:\n        uuid (str): UUID of a result.\n        timeout (float, optional): Timeout in seconds. Defaults to 60.0.\n        interval (float, optional): Interval in seconds. Defaults to 1.0.\n        initial_wait (float | None, optional): Initial wait time in seconds. Set None to disable. Defaults to 10.0.\n    \"\"\"\n    session = self._get_session()\n    req = session.build_request(\"HEAD\", f\"/api/v1/result/{uuid}/\")\n\n    scanned_at = self._scan_uuid_timestamp_memo.get(uuid)\n    if scanned_at and initial_wait:\n        elapsed = time.time() - scanned_at\n        if elapsed &lt; initial_wait:\n            time.sleep(initial_wait - elapsed)\n\n    start_time = time.time()\n    while True:\n        res = self._send_request(session, req)\n        if res.status_code == 200:\n            self._scan_uuid_timestamp_memo.pop(uuid, None)\n            return\n\n        if time.time() - start_time &gt; timeout:\n            raise TimeoutError(\"Timeout waiting for scan result.\")\n\n        time.sleep(interval)\n</code></pre>"},{"location":"references/errors/","title":"Errors","text":""},{"location":"references/errors/#urlscan.APIError","title":"<code>urlscan.APIError</code>","text":"<p>               Bases: <code>URLScanError</code></p> Source code in <code>src/urlscan/error.py</code> <pre><code>class APIError(URLScanError):\n    def __init__(self, message: str, *, status: int, description: str | None = None):\n        self.message = message\n        self.description = description\n        self.status = status\n        super().__init__(message)\n</code></pre>"},{"location":"references/errors/#urlscan.RateLimitError","title":"<code>urlscan.RateLimitError</code>","text":"<p>               Bases: <code>APIError</code></p> Source code in <code>src/urlscan/error.py</code> <pre><code>class RateLimitError(APIError):\n    def __init__(\n        self,\n        message: str,\n        *,\n        status: int,\n        rate_limit_reset_after: float,\n        description: str | None = None,\n    ):\n        super().__init__(message, description=description, status=status)\n        self.rate_limit_reset_after = rate_limit_reset_after\n</code></pre>"},{"location":"references/iterator/","title":"Iterator","text":""},{"location":"references/iterator/#urlscan.SearchIterator","title":"<code>urlscan.SearchIterator</code>","text":"<p>Search iterator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from urlscan import Client\n&gt;&gt;&gt;&gt; with Client(\"&lt;your_api_key&gt;\") as client:\n&gt;&gt;&gt;     for result in client.search(\"page.domain:example.com\"):\n&gt;&gt;&gt;         print(result[\"_id\"], result[\"page\"][\"url\"])\n</code></pre> Source code in <code>src/urlscan/iterator.py</code> <pre><code>class SearchIterator:\n    \"\"\"\n    Search iterator.\n\n    Examples:\n        &gt;&gt;&gt; from urlscan import Client\n        &gt;&gt;&gt;&gt; with Client(\"&lt;your_api_key&gt;\") as client:\n        &gt;&gt;&gt;     for result in client.search(\"page.domain:example.com\"):\n        &gt;&gt;&gt;         print(result[\"_id\"], result[\"page\"][\"url\"])\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"Client\",\n        *,\n        q: str,\n        search_after: str | None = None,\n        size: int = 100,\n        limit: int | None = None,\n    ):\n        \"\"\"\n        Args:\n            client (Client): Client.\n            q (str): Search query.\n            search_after (str | None, optional): Search after to retrieve next results. Defaults to None.\n            size (int, optional): Number of results returned in a search. Defaults to 100.\n            limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n        \"\"\"\n        self._client = client\n        self._size = size\n        self._q = q\n        self._search_after = search_after\n\n        self._results: list[dict] = []\n        self._limit = limit\n        self._count = 0\n        self._total: int | None = None\n        self._has_more: bool = True\n\n    def _parse_response(self, data: dict) -&gt; tuple[list[dict], int]:\n        results: list[dict] = data[\"results\"]\n        total: int = data[\"total\"]\n        return results, total\n\n    def _get(self):\n        data = self._client.get_json(\n            \"/api/v1/search/\",\n            params={\n                \"q\": self._q,\n                \"size\": self._size,\n                \"search_after\": self._search_after,\n            },\n        )\n        return self._parse_response(data)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._limit and self._count &gt;= self._limit:\n            raise StopIteration()\n\n        if not self._results and (self._count == 0 or self._has_more):\n            self._results, total = self._get()\n\n            # NOTE: total should be set only once (to ignore newly added results after the first request)\n            self._total = self._total or total\n            if self._total != MAX_TOTAL:\n                self._has_more = self._total &gt; (self._count + len(self._results))\n            else:\n                self._has_more = len(self._results) &gt;= self._size\n\n            if len(self._results) &gt; 0:\n                last_result = self._results[-1]\n                sort: list[str | int] = last_result[\"sort\"]\n                self._search_after = \",\".join(str(x) for x in sort)\n\n        if not self._results:\n            raise StopIteration()\n\n        result = self._results.pop(0)\n        self._count += 1\n        return result\n</code></pre>"},{"location":"references/iterator/#urlscan.SearchIterator.__init__","title":"<code>__init__(client, *, q, search_after=None, size=100, limit=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>Client.</p> required <code>q</code> <code>str</code> <p>Search query.</p> required <code>search_after</code> <code>str | None</code> <p>Search after to retrieve next results. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>Number of results returned in a search. Defaults to 100.</p> <code>100</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results that will be returned by the iterator. Defaults to None.</p> <code>None</code> Source code in <code>src/urlscan/iterator.py</code> <pre><code>def __init__(\n    self,\n    client: \"Client\",\n    *,\n    q: str,\n    search_after: str | None = None,\n    size: int = 100,\n    limit: int | None = None,\n):\n    \"\"\"\n    Args:\n        client (Client): Client.\n        q (str): Search query.\n        search_after (str | None, optional): Search after to retrieve next results. Defaults to None.\n        size (int, optional): Number of results returned in a search. Defaults to 100.\n        limit (int | None, optional): Maximum number of results that will be returned by the iterator. Defaults to None.\n    \"\"\"\n    self._client = client\n    self._size = size\n    self._q = q\n    self._search_after = search_after\n\n    self._results: list[dict] = []\n    self._limit = limit\n    self._count = 0\n    self._total: int | None = None\n    self._has_more: bool = True\n</code></pre>"}]}